sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:34:35 and 当前时间 <=2023.01.09 10:29:55 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:09:10   AP305   8466.0  TODO
1   2023-01-09 10:09:11   c2305   2884.0  TODO
2   2023-01-09 10:09:11   i2305    820.0  TODO
3   2023-01-09 10:09:07   j2305   2726.0  TODO
4   2023-01-09 10:09:11  jd2305   4351.0  TODO
5   2023-01-09 10:09:10   l2305   8024.0  TODO
6   2023-01-09 10:09:09  lh2303  15740.0  TODO
7   2023-01-09 10:09:11   m2305   3808.0  TODO
8   2023-01-09 10:09:11  rb2305   4098.0  TODO
9   2023-01-09 10:09:11  sp2305   6528.0  TODO
10  2023-01-09 10:09:11   y2305   8634.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:35:13 and 当前时间 <=2023.01.09 10:30:33 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:10:38   AP305   8465.0  TODO
1   2023-01-09 10:10:35   c2305   2884.0  TODO
2   2023-01-09 10:10:38   i2305    820.0  TODO
3   2023-01-09 10:10:36   j2305   2724.0  TODO
4   2023-01-09 10:10:38  jd2305   4350.0  TODO
5   2023-01-09 10:10:36   l2305   8026.0  TODO
6   2023-01-09 10:10:37  lh2303  15725.0  TODO
7   2023-01-09 10:10:38   m2305   3813.0  TODO
8   2023-01-09 10:10:38  rb2305   4095.0  TODO
9   2023-01-09 10:10:38  sp2305   6516.0  TODO
10  2023-01-09 10:10:38   y2305   8630.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:35:51 and 当前时间 <=2023.01.09 10:31:11 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:11:29   AP305   8463.0  TODO
1   2023-01-09 10:11:27   c2305   2884.0  TODO
2   2023-01-09 10:11:29   i2305    821.5  TODO
3   2023-01-09 10:11:22   j2305   2725.5  TODO
4   2023-01-09 10:11:29  jd2305   4349.0  TODO
5   2023-01-09 10:11:29   l2305   8027.0  TODO
6   2023-01-09 10:11:26  lh2303  15725.0  TODO
7   2023-01-09 10:11:27   m2305   3812.0  TODO
8   2023-01-09 10:11:29  rb2305   4098.0  TODO
9   2023-01-09 10:11:29  sp2305   6514.0  TODO
10  2023-01-09 10:11:29   y2305   8634.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:36:29 and 当前时间 <=2023.01.09 10:31:49 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:11:53   AP305   8467.0  TODO
1   2023-01-09 10:11:50   c2305   2884.0  TODO
2   2023-01-09 10:11:54   i2305    821.0  TODO
3   2023-01-09 10:11:53   j2305   2725.5  TODO
4   2023-01-09 10:11:53  jd2305   4350.0  TODO
5   2023-01-09 10:11:54   l2305   8028.0  TODO
6   2023-01-09 10:11:46  lh2303  15720.0  TODO
7   2023-01-09 10:11:54   m2305   3812.0  TODO
8   2023-01-09 10:11:54  rb2305   4099.0  TODO
9   2023-01-09 10:11:54  sp2305   6510.0  TODO
10  2023-01-09 10:11:54   y2305   8636.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:37:07 and 当前时间 <=2023.01.09 10:32:27 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
更新完成

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:12:45   AP305   8465.0  TODO
1   2023-01-09 10:12:43   c2305   2883.0  TODO
2   2023-01-09 10:12:45   i2305    820.5  TODO
3   2023-01-09 10:12:45   j2305   2725.0  TODO
4   2023-01-09 10:12:44  jd2305   4350.0  TODO
5   2023-01-09 10:12:45   l2305   8025.0  TODO
6   2023-01-09 10:12:45  lh2303  15730.0  TODO
7   2023-01-09 10:12:45   m2305   3811.0  TODO
8   2023-01-09 10:12:45  rb2305   4099.0  TODO
9   2023-01-09 10:12:45  sp2305   6516.0  TODO
10  2023-01-09 10:12:45   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:37:45 and 当前时间 <=2023.01.09 10:33:05 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:13:10   AP305   8467.0  TODO
1   2023-01-09 10:13:09   c2305   2884.0  TODO
2   2023-01-09 10:13:10   i2305    821.0  TODO
3   2023-01-09 10:13:10   j2305   2726.5  TODO
4   2023-01-09 10:13:08  jd2305   4349.0  TODO
5   2023-01-09 10:13:10   l2305   8028.0  TODO
6   2023-01-09 10:13:10  lh2303  15730.0  TODO
7   2023-01-09 10:13:10   m2305   3811.0  TODO
8   2023-01-09 10:13:11  rb2305   4100.0  TODO
9   2023-01-09 10:13:11  sp2305   6516.0  TODO
10  2023-01-09 10:13:10   y2305   8632.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:38:23 and 当前时间 <=2023.01.09 10:33:43 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:14:01   AP305   8467.0  TODO
1   2023-01-09 10:14:01   c2305   2885.0  TODO
2   2023-01-09 10:14:01   i2305    820.5  TODO
3   2023-01-09 10:13:58   j2305   2722.5  TODO
4   2023-01-09 10:13:57  jd2305   4349.0  TODO
5   2023-01-09 10:14:01   l2305   8029.0  TODO
6   2023-01-09 10:14:00  lh2303  15730.0  TODO
7   2023-01-09 10:14:01   m2305   3811.0  TODO
8   2023-01-09 10:14:01  rb2305   4098.0  TODO
9   2023-01-09 10:14:01  sp2305   6516.0  TODO
10  2023-01-09 10:14:01   y2305   8634.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:39:01 and 当前时间 <=2023.01.09 10:34:21 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:14:25   AP305   8464.0  TODO
1   2023-01-09 10:14:24   c2305   2884.0  TODO
2   2023-01-09 10:14:26   i2305    820.0  TODO
3   2023-01-09 10:14:22   j2305   2722.5  TODO
4   2023-01-09 10:14:23  jd2305   4349.0  TODO
5   2023-01-09 10:14:26   l2305   8029.0  TODO
6   2023-01-09 10:14:25  lh2303  15720.0  TODO
7   2023-01-09 10:14:26   m2305   3810.0  TODO
8   2023-01-09 10:14:26  rb2305   4097.0  TODO
9   2023-01-09 10:14:26  sp2305   6514.0  TODO
10  2023-01-09 10:14:26   y2305   8636.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:39:39 and 当前时间 <=2023.01.09 10:34:59 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:15:00   AP305   8463.0  TODO
1   2023-01-09 10:15:01   c2305   2884.0  TODO
2   2023-01-09 10:15:01   i2305    819.5  TODO
3   2023-01-09 10:15:01   j2305   2723.0  TODO
4   2023-01-09 10:14:58  jd2305   4349.0  TODO
5   2023-01-09 10:15:01   l2305   8028.0  TODO
6   2023-01-09 10:14:59  lh2303  15710.0  TODO
7   2023-01-09 10:15:01   m2305   3813.0  TODO
8   2023-01-09 10:15:01  rb2305   4096.0  TODO
9   2023-01-09 10:15:01  sp2305   6512.0  TODO
10  2023-01-09 10:15:01   y2305   8636.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:40:17 and 当前时间 <=2023.01.09 10:35:37 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:15:00   AP305   8463.0  TODO
1   2023-01-09 10:15:01   c2305   2884.0  TODO
2   2023-01-09 10:15:01   i2305    819.5  TODO
3   2023-01-09 10:15:01   j2305   2723.0  TODO
4   2023-01-09 10:14:58  jd2305   4349.0  TODO
5   2023-01-09 10:15:01   l2305   8028.0  TODO
6   2023-01-09 10:14:59  lh2303  15710.0  TODO
7   2023-01-09 10:15:01   m2305   3813.0  TODO
8   2023-01-09 10:15:01  rb2305   4096.0  TODO
9   2023-01-09 10:15:01  sp2305   6512.0  TODO
10  2023-01-09 10:15:01   y2305   8636.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:40:55 and 当前时间 <=2023.01.09 10:36:15 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
更新完成

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:15:00   AP305   8463.0  TODO
1   2023-01-09 10:15:01   c2305   2884.0  TODO
2   2023-01-09 10:15:01   i2305    819.5  TODO
3   2023-01-09 10:15:01   j2305   2723.0  TODO
4   2023-01-09 10:14:58  jd2305   4349.0  TODO
5   2023-01-09 10:15:01   l2305   8028.0  TODO
6   2023-01-09 10:14:59  lh2303  15710.0  TODO
7   2023-01-09 10:15:01   m2305   3813.0  TODO
8   2023-01-09 10:15:01  rb2305   4096.0  TODO
9   2023-01-09 10:15:01  sp2305   6512.0  TODO
10  2023-01-09 10:15:01   y2305   8636.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:41:33 and 当前时间 <=2023.01.09 10:36:53 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:15:00   AP305   8463.0  TODO
1   2023-01-09 10:15:01   c2305   2884.0  TODO
2   2023-01-09 10:15:01   i2305    819.5  TODO
3   2023-01-09 10:15:01   j2305   2723.0  TODO
4   2023-01-09 10:14:58  jd2305   4349.0  TODO
5   2023-01-09 10:15:01   l2305   8028.0  TODO
6   2023-01-09 10:14:59  lh2303  15710.0  TODO
7   2023-01-09 10:15:01   m2305   3813.0  TODO
8   2023-01-09 10:15:01  rb2305   4096.0  TODO
9   2023-01-09 10:15:01  sp2305   6512.0  TODO
10  2023-01-09 10:15:01   y2305   8636.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:42:11 and 当前时间 <=2023.01.09 10:37:31 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:15:00   AP305   8463.0  TODO
1   2023-01-09 10:15:01   c2305   2884.0  TODO
2   2023-01-09 10:15:01   i2305    819.5  TODO
3   2023-01-09 10:15:01   j2305   2723.0  TODO
4   2023-01-09 10:14:58  jd2305   4349.0  TODO
5   2023-01-09 10:15:01   l2305   8028.0  TODO
6   2023-01-09 10:14:59  lh2303  15710.0  TODO
7   2023-01-09 10:15:01   m2305   3813.0  TODO
8   2023-01-09 10:15:01  rb2305   4096.0  TODO
9   2023-01-09 10:15:01  sp2305   6512.0  TODO
10  2023-01-09 10:15:01   y2305   8636.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:42:49 and 当前时间 <=2023.01.09 10:38:09 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:43:27 and 当前时间 <=2023.01.09 10:38:47 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:44:05 and 当前时间 <=2023.01.09 10:39:25 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:44:43 and 当前时间 <=2023.01.09 10:40:03 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:46:22 and 当前时间 <=2023.01.09 10:41:42 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:47:00 and 当前时间 <=2023.01.09 10:42:20 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:47:38 and 当前时间 <=2023.01.09 10:42:58 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:48:16 and 当前时间 <=2023.01.09 10:43:36 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:48:54 and 当前时间 <=2023.01.09 10:44:14 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
更新完成

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:49:32 and 当前时间 <=2023.01.09 10:44:52 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:50:10 and 当前时间 <=2023.01.09 10:45:30 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:50:49 and 当前时间 <=2023.01.09 10:46:09 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:51:26 and 当前时间 <=2023.01.09 10:46:46 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:52:04 and 当前时间 <=2023.01.09 10:47:24 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:52:42 and 当前时间 <=2023.01.09 10:48:02 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);
Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 10:28:15 CST)" was missed by 0:00:01.029871


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:53:20 and 当前时间 <=2023.01.09 10:48:40 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:53:58 and 当前时间 <=2023.01.09 10:49:18 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:54:36 and 当前时间 <=2023.01.09 10:49:56 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:55:14 and 当前时间 <=2023.01.09 10:50:34 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:30:52   AP305   8472.0  TODO
1   2023-01-09 10:30:50   c2305   2882.0  TODO
2   2023-01-09 10:30:52   i2305    821.0  TODO
3   2023-01-09 10:30:51   j2305   2727.5  TODO
4   2023-01-09 10:30:52  jd2305   4348.0  TODO
5   2023-01-09 10:30:52   l2305   8026.0  TODO
6   2023-01-09 10:30:52  lh2303  15735.0  TODO
7   2023-01-09 10:30:52   m2305   3811.0  TODO
8   2023-01-09 10:30:51  rb2305   4096.0  TODO
9   2023-01-09 10:30:51  sp2305   6510.0  TODO
10  2023-01-09 10:30:52   y2305   8636.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:55:52 and 当前时间 <=2023.01.09 10:51:12 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:31:17   AP305   8469.0  TODO
1   2023-01-09 10:31:17   c2305   2884.0  TODO
2   2023-01-09 10:31:17   i2305    819.5  TODO
3   2023-01-09 10:31:17   j2305   2725.5  TODO
4   2023-01-09 10:31:16  jd2305   4349.0  TODO
5   2023-01-09 10:31:17   l2305   8023.0  TODO
6   2023-01-09 10:31:17  lh2303  15745.0  TODO
7   2023-01-09 10:31:17   m2305   3810.0  TODO
8   2023-01-09 10:31:17  rb2305   4094.0  TODO
9   2023-01-09 10:31:17  sp2305   6512.0  TODO
10  2023-01-09 10:31:17   y2305   8640.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:56:30 and 当前时间 <=2023.01.09 10:51:50 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:32:08   AP305   8469.0  TODO
1   2023-01-09 10:32:07   c2305   2883.0  TODO
2   2023-01-09 10:32:08   i2305    819.5  TODO
3   2023-01-09 10:32:06   j2305   2725.5  TODO
4   2023-01-09 10:32:08  jd2305   4351.0  TODO
5   2023-01-09 10:32:08   l2305   8026.0  TODO
6   2023-01-09 10:32:08  lh2303  15745.0  TODO
7   2023-01-09 10:32:08   m2305   3809.0  TODO
8   2023-01-09 10:32:08  rb2305   4096.0  TODO
9   2023-01-09 10:32:08  sp2305   6514.0  TODO
10  2023-01-09 10:32:08   y2305   8634.0  TODORun time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 10:32:51 CST)" was missed by 0:00:11.810185
Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 10:33:03 CST)" was missed by 0:00:06.270982
sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:58:26 and 当前时间 <=2023.01.09 10:53:46 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:32:32   AP305   8468.0  TODO
1   2023-01-09 10:32:33   c2305   2883.0  TODO
2   2023-01-09 10:32:33   i2305    820.0  TODO
3   2023-01-09 10:32:32   j2305   2727.0  TODO
4   2023-01-09 10:32:33  jd2305   4352.0  TODO
5   2023-01-09 10:32:33   l2305   8030.0  TODO
6   2023-01-09 10:32:30  lh2303  15750.0  TODO
7   2023-01-09 10:32:33   m2305   3808.0  TODO
8   2023-01-09 10:32:33  rb2305   4097.0  TODO
9   2023-01-09 10:32:33  sp2305   6512.0  TODO
10  2023-01-09 10:32:33   y2305   8632.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:59:04 and 当前时间 <=2023.01.09 10:54:24 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:34:28   AP305   8473.0  TODO
1   2023-01-09 10:34:27   c2305   2887.0  TODO
2   2023-01-09 10:34:28   i2305    822.0  TODO
3   2023-01-09 10:34:27   j2305   2731.5  TODO
4   2023-01-09 10:34:28  jd2305   4350.0  TODO
5   2023-01-09 10:34:27   l2305   8031.0  TODO
6   2023-01-09 10:34:28  lh2303  15765.0  TODO
7   2023-01-09 10:34:28   m2305   3810.0  TODO
8   2023-01-09 10:34:28  rb2305   4100.0  TODO
9   2023-01-09 10:34:28  sp2305   6520.0  TODO
10  2023-01-09 10:34:28   y2305   8642.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 13:59:42 and 当前时间 <=2023.01.09 10:55:02 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:35:19   AP305   8472.0  TODO
1   2023-01-09 10:35:20   c2305   2887.0  TODO
2   2023-01-09 10:35:20   i2305    822.0  TODO
3   2023-01-09 10:35:19   j2305   2735.0  TODO
4   2023-01-09 10:35:17  jd2305   4349.0  TODO
5   2023-01-09 10:35:18   l2305   8035.0  TODO
6   2023-01-09 10:35:19  lh2303  15775.0  TODO
7   2023-01-09 10:35:19   m2305   3809.0  TODO
8   2023-01-09 10:35:19  rb2305   4102.0  TODO
9   2023-01-09 10:35:19  sp2305   6516.0  TODO
10  2023-01-09 10:35:19   y2305   8652.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:00:20 and 当前时间 <=2023.01.09 10:55:40 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:35:45   AP305   8471.0  TODO
1   2023-01-09 10:35:44   c2305   2886.0  TODO
2   2023-01-09 10:35:45   i2305    823.0  TODO
3   2023-01-09 10:35:45   j2305   2735.0  TODO
4   2023-01-09 10:35:43  jd2305   4349.0  TODO
5   2023-01-09 10:35:45   l2305   8036.0  TODO
6   2023-01-09 10:35:44  lh2303  15770.0  TODO
7   2023-01-09 10:35:45   m2305   3807.0  TODO
8   2023-01-09 10:35:45  rb2305   4104.0  TODO
9   2023-01-09 10:35:45  sp2305   6514.0  TODO
10  2023-01-09 10:35:45   y2305   8648.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:00:58 and 当前时间 <=2023.01.09 10:56:18 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
更新完成

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:36:36   AP305   8473.0  TODO
1   2023-01-09 10:36:33   c2305   2885.0  TODO
2   2023-01-09 10:36:36   i2305    822.0  TODO
3   2023-01-09 10:36:36   j2305   2732.5  TODO
4   2023-01-09 10:36:35  jd2305   4347.0  TODO
5   2023-01-09 10:36:36   l2305   8035.0  TODO
6   2023-01-09 10:36:31  lh2303  15755.0  TODO
7   2023-01-09 10:36:36   m2305   3807.0  TODO
8   2023-01-09 10:36:36  rb2305   4104.0  TODO
9   2023-01-09 10:36:36  sp2305   6514.0  TODO
10  2023-01-09 10:36:35   y2305   8648.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:01:36 and 当前时间 <=2023.01.09 10:56:56 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:37:01   AP305   8476.0  TODO
1   2023-01-09 10:37:01   c2305   2885.0  TODO
2   2023-01-09 10:37:01   i2305    822.0  TODO
3   2023-01-09 10:36:59   j2305   2734.0  TODO
4   2023-01-09 10:37:01  jd2305   4347.0  TODO
5   2023-01-09 10:37:00   l2305   8034.0  TODO
6   2023-01-09 10:36:59  lh2303  15760.0  TODO
7   2023-01-09 10:37:01   m2305   3806.0  TODO
8   2023-01-09 10:37:01  rb2305   4102.0  TODO
9   2023-01-09 10:37:01  sp2305   6510.0  TODO
10  2023-01-09 10:37:01   y2305   8646.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:02:14 and 当前时间 <=2023.01.09 10:57:34 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:37:52   AP305   8470.0  TODO
1   2023-01-09 10:37:49   c2305   2886.0  TODO
2   2023-01-09 10:37:52   i2305    822.0  TODO
3   2023-01-09 10:37:52   j2305   2732.5  TODO
4   2023-01-09 10:37:50  jd2305   4347.0  TODO
5   2023-01-09 10:37:52   l2305   8033.0  TODO
6   2023-01-09 10:37:51  lh2303  15795.0  TODO
7   2023-01-09 10:37:52   m2305   3806.0  TODO
8   2023-01-09 10:37:52  rb2305   4101.0  TODO
9   2023-01-09 10:37:52  sp2305   6512.0  TODO
10  2023-01-09 10:37:52   y2305   8646.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:02:52 and 当前时间 <=2023.01.09 10:58:12 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:38:18   AP305   8467.0  TODO
1   2023-01-09 10:38:18   c2305   2885.0  TODO
2   2023-01-09 10:38:18   i2305    822.5  TODO
3   2023-01-09 10:38:17   j2305   2731.0  TODO
4   2023-01-09 10:38:16  jd2305   4347.0  TODO
5   2023-01-09 10:38:17   l2305   8033.0  TODO
6   2023-01-09 10:38:17  lh2303  15800.0  TODO
7   2023-01-09 10:38:18   m2305   3806.0  TODO
8   2023-01-09 10:38:17  rb2305   4101.0  TODO
9   2023-01-09 10:38:17  sp2305   6512.0  TODO
10  2023-01-09 10:38:17   y2305   8644.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:03:30 and 当前时间 <=2023.01.09 10:58:50 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:04:08 and 当前时间 <=2023.01.09 10:59:28 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:04:46 and 当前时间 <=2023.01.09 11:00:06 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:05:24 and 当前时间 <=2023.01.09 11:00:44 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:06:02 and 当前时间 <=2023.01.09 11:01:22 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:06:40 and 当前时间 <=2023.01.09 11:02:00 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:07:18 and 当前时间 <=2023.01.09 11:02:38 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:07:56 and 当前时间 <=2023.01.09 11:03:16 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:08:34 and 当前时间 <=2023.01.09 11:03:54 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:10:33 and 当前时间 <=2023.01.09 11:05:53 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:45:03   AP305   8450.0  TODO
1   2023-01-09 10:45:04   c2305   2885.0  TODO
2   2023-01-09 10:45:04   i2305    822.0  TODO
3   2023-01-09 10:45:04   j2305   2728.5  TODO
4   2023-01-09 10:45:04  jd2305   4351.0  TODO
5   2023-01-09 10:45:04   l2305   8041.0  TODO
6   2023-01-09 10:45:04  lh2303  15815.0  TODO
7   2023-01-09 10:45:04   m2305   3807.0  TODO
8   2023-01-09 10:45:04  rb2305   4095.0  TODO
9   2023-01-09 10:45:04  sp2305   6522.0  TODO
10  2023-01-09 10:45:04   y2305   8630.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:11:11 and 当前时间 <=2023.01.09 11:06:31 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:11:49 and 当前时间 <=2023.01.09 11:07:09 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:12:27 and 当前时间 <=2023.01.09 11:07:47 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:13:05 and 当前时间 <=2023.01.09 11:08:25 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:13:43 and 当前时间 <=2023.01.09 11:09:03 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:14:21 and 当前时间 <=2023.01.09 11:09:41 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:14:59 and 当前时间 <=2023.01.09 11:10:19 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:15:37 and 当前时间 <=2023.01.09 11:10:57 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:16:15 and 当前时间 <=2023.01.09 11:11:35 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:16:53 and 当前时间 <=2023.01.09 11:12:13 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:17:31 and 当前时间 <=2023.01.09 11:12:51 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:18:09 and 当前时间 <=2023.01.09 11:13:29 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:18:47 and 当前时间 <=2023.01.09 11:14:07 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:19:25 and 当前时间 <=2023.01.09 11:14:45 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:20:03 and 当前时间 <=2023.01.09 11:15:23 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:20:41 and 当前时间 <=2023.01.09 11:16:01 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);
Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 10:56:14 CST)" was missed by 0:00:02.630571
sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
更新完成
start qry thread
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:22:39 and 当前时间 <=2023.01.09 11:17:59 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:57:07   AP305   8439.0  TODO
1   2023-01-09 10:57:06   c2305   2886.0  TODO
2   2023-01-09 10:57:07   i2305    822.0  TODO
3   2023-01-09 10:57:06   j2305   2724.0  TODO
4   2023-01-09 10:57:05  jd2305   4351.0  TODO
5   2023-01-09 10:57:07   l2305   8019.0  TODO
6   2023-01-09 10:57:05  lh2303  15795.0  TODO
7   2023-01-09 10:57:07   m2305   3808.0  TODO
8   2023-01-09 10:57:07  rb2305   4094.0  TODO
9   2023-01-09 10:57:07  sp2305   6510.0  TODO
10  2023-01-09 10:57:07   y2305   8624.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:23:17 and 当前时间 <=2023.01.09 11:18:37 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:58:42   AP305   8437.0  TODO
1   2023-01-09 10:58:45   c2305   2886.0  TODO
2   2023-01-09 10:58:45   i2305    821.0  TODO
3   2023-01-09 10:58:45   j2305   2723.0  TODO
4   2023-01-09 10:58:44  jd2305   4350.0  TODO
5   2023-01-09 10:58:45   l2305   8016.0  TODO
6   2023-01-09 10:58:45  lh2303  15790.0  TODO
7   2023-01-09 10:58:45   m2305   3807.0  TODO
8   2023-01-09 10:58:45  rb2305   4092.0  TODO
9   2023-01-09 10:58:45  sp2305   6500.0  TODO
10  2023-01-09 10:58:45   y2305   8616.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:23:55 and 当前时间 <=2023.01.09 11:19:15 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 10:59:36   AP305   8439.0  TODO
1   2023-01-09 10:59:33   c2305   2886.0  TODO
2   2023-01-09 10:59:36   i2305    821.0  TODO
3   2023-01-09 10:59:34   j2305   2722.5  TODO
4   2023-01-09 10:59:35  jd2305   4350.0  TODO
5   2023-01-09 10:59:36   l2305   8014.0  TODO
6   2023-01-09 10:59:34  lh2303  15790.0  TODO
7   2023-01-09 10:59:36   m2305   3810.0  TODO
8   2023-01-09 10:59:36  rb2305   4091.0  TODO
9   2023-01-09 10:59:36  sp2305   6500.0  TODO
10  2023-01-09 10:59:36   y2305   8616.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:24:33 and 当前时间 <=2023.01.09 11:19:53 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:00:01   AP305   8440.0  TODO
1   2023-01-09 10:59:58   c2305   2886.0  TODO
2   2023-01-09 11:00:01   i2305    821.0  TODO
3   2023-01-09 11:00:00   j2305   2721.0  TODO
4   2023-01-09 11:00:01  jd2305   4347.0  TODO
5   2023-01-09 11:00:01   l2305   8015.0  TODO
6   2023-01-09 11:00:00  lh2303  15795.0  TODO
7   2023-01-09 11:00:01   m2305   3808.0  TODO
8   2023-01-09 11:00:01  rb2305   4092.0  TODO
9   2023-01-09 11:00:01  sp2305   6500.0  TODO
10  2023-01-09 11:00:01   y2305   8612.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:25:11 and 当前时间 <=2023.01.09 11:20:31 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:00:52   AP305   8442.0  TODO
1   2023-01-09 11:00:46   c2305   2887.0  TODO
2   2023-01-09 11:00:52   i2305    821.0  TODO
3   2023-01-09 11:00:52   j2305   2712.5  TODO
4   2023-01-09 11:00:47  jd2305   4349.0  TODO
5   2023-01-09 11:00:52   l2305   8016.0  TODO
6   2023-01-09 11:00:51  lh2303  15790.0  TODO
7   2023-01-09 11:00:51   m2305   3808.0  TODO
8   2023-01-09 11:00:52  rb2305   4090.0  TODO
9   2023-01-09 11:00:52  sp2305   6504.0  TODO
10  2023-01-09 11:00:52   y2305   8620.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:25:49 and 当前时间 <=2023.01.09 11:21:09 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:26:27 and 当前时间 <=2023.01.09 11:21:47 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:27:05 and 当前时间 <=2023.01.09 11:22:25 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:27:43 and 当前时间 <=2023.01.09 11:23:03 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:28:21 and 当前时间 <=2023.01.09 11:23:41 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:28:59 and 当前时间 <=2023.01.09 11:24:19 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:29:37 and 当前时间 <=2023.01.09 11:24:57 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:30:15 and 当前时间 <=2023.01.09 11:25:35 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:30:53 and 当前时间 <=2023.01.09 11:26:13 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:31:31 and 当前时间 <=2023.01.09 11:26:51 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:32:09 and 当前时间 <=2023.01.09 11:27:29 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:32:47 and 当前时间 <=2023.01.09 11:28:07 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:33:25 and 当前时间 <=2023.01.09 11:28:45 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);
sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:34:32 and 当前时间 <=2023.01.09 11:29:52 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:09:23   AP305   8433.0  TODO
1   2023-01-09 11:09:22   c2305   2887.0  TODO
2   2023-01-09 11:09:23   i2305    820.5  TODO
3   2023-01-09 11:09:23   j2305   2709.0  TODO
4   2023-01-09 11:09:23  jd2305   4345.0  TODO
5   2023-01-09 11:09:23   l2305   7999.0  TODO
6   2023-01-09 11:09:21  lh2303  15770.0  TODO
7   2023-01-09 11:09:23   m2305   3809.0  TODO
8   2023-01-09 11:09:23  rb2305   4090.0  TODO
9   2023-01-09 11:09:23  sp2305   6488.0  TODO
10  2023-01-09 11:09:23   y2305   8618.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:35:10 and 当前时间 <=2023.01.09 11:30:30 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:10:31   AP305   8437.0  TODO
1   2023-01-09 11:10:31   c2305   2888.0  TODO
2   2023-01-09 11:10:31   i2305    819.5  TODO
3   2023-01-09 11:10:31   j2305   2708.0  TODO
4   2023-01-09 11:10:31  jd2305   4347.0  TODO
5   2023-01-09 11:10:31   l2305   8001.0  TODO
6   2023-01-09 11:10:29  lh2303  15755.0  TODO
7   2023-01-09 11:10:31   m2305   3808.0  TODO
8   2023-01-09 11:10:31  rb2305   4085.0  TODO
9   2023-01-09 11:10:31  sp2305   6488.0  TODO
10  2023-01-09 11:10:31   y2305   8624.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:35:48 and 当前时间 <=2023.01.09 11:31:08 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:11:26   AP305   8440.0  TODO
1   2023-01-09 11:11:23   c2305   2888.0  TODO
2   2023-01-09 11:11:26   i2305    818.5  TODO
3   2023-01-09 11:11:26   j2305   2707.0  TODO
4   2023-01-09 11:11:26  jd2305   4346.0  TODO
5   2023-01-09 11:11:26   l2305   8000.0  TODO
6   2023-01-09 11:11:19  lh2303  15760.0  TODO
7   2023-01-09 11:11:26   m2305   3809.0  TODO
8   2023-01-09 11:11:26  rb2305   4082.0  TODO
9   2023-01-09 11:11:26  sp2305   6490.0  TODO
10  2023-01-09 11:11:26   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:36:26 and 当前时间 <=2023.01.09 11:31:46 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:11:51   AP305   8440.0  TODO
1   2023-01-09 11:11:51   c2305   2888.0  TODO
2   2023-01-09 11:11:51   i2305    818.0  TODO
3   2023-01-09 11:11:51   j2305   2707.0  TODO
4   2023-01-09 11:11:51  jd2305   4346.0  TODO
5   2023-01-09 11:11:51   l2305   8001.0  TODO
6   2023-01-09 11:11:50  lh2303  15770.0  TODO
7   2023-01-09 11:11:51   m2305   3808.0  TODO
8   2023-01-09 11:11:51  rb2305   4082.0  TODO
9   2023-01-09 11:11:51  sp2305   6492.0  TODO
10  2023-01-09 11:11:51   y2305   8630.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:37:04 and 当前时间 <=2023.01.09 11:32:24 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);

更新完成

    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:12:42   AP305   8447.0  TODO
1   2023-01-09 11:12:36   c2305   2888.0  TODO
2   2023-01-09 11:12:42   i2305    818.5  TODO
3   2023-01-09 11:12:42   j2305   2710.5  TODO
4   2023-01-09 11:12:41  jd2305   4345.0  TODO
5   2023-01-09 11:12:42   l2305   8004.0  TODO
6   2023-01-09 11:12:38  lh2303  15765.0  TODO
7   2023-01-09 11:12:41   m2305   3808.0  TODO
8   2023-01-09 11:12:42  rb2305   4083.0  TODO
9   2023-01-09 11:12:42  sp2305   6490.0  TODO
10  2023-01-09 11:12:42   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:37:42 and 当前时间 <=2023.01.09 11:33:02 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:13:07   AP305   8445.0  TODO
1   2023-01-09 11:13:05   c2305   2888.0  TODO
2   2023-01-09 11:13:07   i2305    819.0  TODO
3   2023-01-09 11:13:01   j2305   2709.5  TODO
4   2023-01-09 11:13:07  jd2305   4346.0  TODO
5   2023-01-09 11:13:07   l2305   8004.0  TODO
6   2023-01-09 11:13:07  lh2303  15760.0  TODO
7   2023-01-09 11:13:07   m2305   3809.0  TODO
8   2023-01-09 11:13:07  rb2305   4081.0  TODO
9   2023-01-09 11:13:07  sp2305   6490.0  TODO
10  2023-01-09 11:13:07   y2305   8624.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:38:20 and 当前时间 <=2023.01.09 11:33:40 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:13:58   AP305   8440.0  TODO
1   2023-01-09 11:13:58   c2305   2888.0  TODO
2   2023-01-09 11:13:58   i2305    819.0  TODO
3   2023-01-09 11:13:56   j2305   2710.0  TODO
4   2023-01-09 11:13:58  jd2305   4348.0  TODO
5   2023-01-09 11:13:57   l2305   8002.0  TODO
6   2023-01-09 11:13:55  lh2303  15765.0  TODO
7   2023-01-09 11:13:58   m2305   3810.0  TODO
8   2023-01-09 11:13:58  rb2305   4085.0  TODO
9   2023-01-09 11:13:58  sp2305   6486.0  TODO
10  2023-01-09 11:13:58   y2305   8622.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:38:58 and 当前时间 <=2023.01.09 11:34:18 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:14:24   AP305   8445.0  TODO
1   2023-01-09 11:14:21   c2305   2887.0  TODO
2   2023-01-09 11:14:24   i2305    818.0  TODO
3   2023-01-09 11:14:22   j2305   2708.0  TODO
4   2023-01-09 11:14:23  jd2305   4349.0  TODO
5   2023-01-09 11:14:23   l2305   8002.0  TODO
6   2023-01-09 11:14:13  lh2303  15765.0  TODO
7   2023-01-09 11:14:24   m2305   3809.0  TODO
8   2023-01-09 11:14:24  rb2305   4082.0  TODO
9   2023-01-09 11:14:24  sp2305   6484.0  TODO
10  2023-01-09 11:14:24   y2305   8616.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:39:36 and 当前时间 <=2023.01.09 11:34:56 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:15:15   AP305   8451.0  TODO
1   2023-01-09 11:15:14   c2305   2887.0  TODO
2   2023-01-09 11:15:15   i2305    819.5  TODO
3   2023-01-09 11:15:15   j2305   2714.0  TODO
4   2023-01-09 11:15:15  jd2305   4351.0  TODO
5   2023-01-09 11:15:15   l2305   8004.0  TODO
6   2023-01-09 11:15:14  lh2303  15775.0  TODO
7   2023-01-09 11:15:15   m2305   3809.0  TODO
8   2023-01-09 11:15:14  rb2305   4088.0  TODO
9   2023-01-09 11:15:14  sp2305   6484.0  TODO
10  2023-01-09 11:15:14   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:40:14 and 当前时间 <=2023.01.09 11:35:34 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:15:40   AP305   8449.0  TODO
1   2023-01-09 11:15:35   c2305   2888.0  TODO
2   2023-01-09 11:15:40   i2305    817.5  TODO
3   2023-01-09 11:15:40   j2305   2709.0  TODO
4   2023-01-09 11:15:39  jd2305   4351.0  TODO
5   2023-01-09 11:15:40   l2305   8000.0  TODO
6   2023-01-09 11:15:39  lh2303  15775.0  TODO
7   2023-01-09 11:15:40   m2305   3808.0  TODO
8   2023-01-09 11:15:40  rb2305   4080.0  TODO
9   2023-01-09 11:15:40  sp2305   6486.0  TODO
10  2023-01-09 11:15:40   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:40:52 and 当前时间 <=2023.01.09 11:36:12 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:16:30   AP305   8452.0  TODO
1   2023-01-09 11:16:30   c2305   2887.0  TODO
2   2023-01-09 11:16:31   i2305    818.0  TODO
3   2023-01-09 11:16:28   j2305   2710.0  TODO
4   2023-01-09 11:16:31  jd2305   4353.0  TODO
5   2023-01-09 11:16:31   l2305   7998.0  TODO
6   2023-01-09 11:16:28  lh2303  15765.0  TODO
7   2023-01-09 11:16:30   m2305   3808.0  TODO
8   2023-01-09 11:16:31  rb2305   4082.0  TODO
9   2023-01-09 11:16:31  sp2305   6486.0  TODO
10  2023-01-09 11:16:31   y2305   8622.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:41:30 and 当前时间 <=2023.01.09 11:36:50 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:16:56   AP305   8453.0  TODO
1   2023-01-09 11:16:56   c2305   2888.0  TODO
2   2023-01-09 11:16:56   i2305    818.5  TODO
3   2023-01-09 11:16:56   j2305   2711.0  TODO
4   2023-01-09 11:16:56  jd2305   4352.0  TODO
5   2023-01-09 11:16:56   l2305   7997.0  TODO
6   2023-01-09 11:16:54  lh2303  15765.0  TODO
7   2023-01-09 11:16:55   m2305   3809.0  TODO
8   2023-01-09 11:16:56  rb2305   4084.0  TODO
9   2023-01-09 11:16:56  sp2305   6484.0  TODO
10  2023-01-09 11:16:56   y2305   8622.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:42:08 and 当前时间 <=2023.01.09 11:37:28 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:17:47   AP305   8456.0  TODO
1   2023-01-09 11:17:46   c2305   2887.0  TODO
2   2023-01-09 11:17:47   i2305    819.0  TODO
3   2023-01-09 11:17:47   j2305   2711.5  TODO
4   2023-01-09 11:17:47  jd2305   4354.0  TODO
5   2023-01-09 11:17:46   l2305   7999.0  TODO
6   2023-01-09 11:17:40  lh2303  15760.0  TODO
7   2023-01-09 11:17:47   m2305   3809.0  TODO
8   2023-01-09 11:17:47  rb2305   4085.0  TODO
9   2023-01-09 11:17:47  sp2305   6484.0  TODO
10  2023-01-09 11:17:47   y2305   8624.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:42:46 and 当前时间 <=2023.01.09 11:38:06 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:18:12   AP305   8454.0  TODO
1   2023-01-09 11:18:08   c2305   2888.0  TODO
2   2023-01-09 11:18:13   i2305    818.5  TODO
3   2023-01-09 11:18:13   j2305   2713.0  TODO
4   2023-01-09 11:18:12  jd2305   4355.0  TODO
5   2023-01-09 11:18:13   l2305   7997.0  TODO
6   2023-01-09 11:18:12  lh2303  15760.0  TODO
7   2023-01-09 11:18:12   m2305   3809.0  TODO
8   2023-01-09 11:18:12  rb2305   4084.0  TODO
9   2023-01-09 11:18:12  sp2305   6484.0  TODO
10  2023-01-09 11:18:12   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:43:24 and 当前时间 <=2023.01.09 11:38:44 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:19:03   AP305   8452.0  TODO
1   2023-01-09 11:19:03   c2305   2887.0  TODO
2   2023-01-09 11:19:03   i2305    818.0  TODO
3   2023-01-09 11:19:03   j2305   2712.0  TODO
4   2023-01-09 11:18:59  jd2305   4354.0  TODO
5   2023-01-09 11:19:03   l2305   7998.0  TODO
6   2023-01-09 11:19:00  lh2303  15765.0  TODO
7   2023-01-09 11:19:03   m2305   3812.0  TODO
8   2023-01-09 11:19:03  rb2305   4082.0  TODO
9   2023-01-09 11:19:03  sp2305   6486.0  TODO
10  2023-01-09 11:19:03   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:44:02 and 当前时间 <=2023.01.09 11:39:22 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:19:28   AP305   8452.0  TODO
1   2023-01-09 11:19:27   c2305   2888.0  TODO
2   2023-01-09 11:19:28   i2305    817.5  TODO
3   2023-01-09 11:19:28   j2305   2711.0  TODO
4   2023-01-09 11:19:28  jd2305   4354.0  TODO
5   2023-01-09 11:19:28   l2305   7998.0  TODO
6   2023-01-09 11:19:27  lh2303  15765.0  TODO
7   2023-01-09 11:19:28   m2305   3813.0  TODO
8   2023-01-09 11:19:28  rb2305   4083.0  TODO
9   2023-01-09 11:19:28  sp2305   6486.0  TODO
10  2023-01-09 11:19:28   y2305   8626.0  TODORun time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 11:20:13 CST)" was missed by 0:00:02.661435

'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:44:40 and 当前时间 <=2023.01.09 11:40:00 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:45:18 and 当前时间 <=2023.01.09 11:40:38 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
更新完成
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:46:31 and 当前时间 <=2023.01.09 11:41:51 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 11:21:09   AP305   8448.0  TODO
1   2023-01-09 11:21:08   c2305   2887.0  TODO
2   2023-01-09 11:21:09   i2305    817.5  TODO
3   2023-01-09 11:21:09   j2305   2712.5  TODO
4   2023-01-09 11:21:09  jd2305   4354.0  TODO
5   2023-01-09 11:21:09   l2305   8000.0  TODO
6   2023-01-09 11:21:08  lh2303  15740.0  TODO
7   2023-01-09 11:21:09   m2305   3812.0  TODO
8   2023-01-09 11:21:09  rb2305   4082.0  TODO
9   2023-01-09 11:21:09  sp2305   6480.0  TODO
10  2023-01-09 11:21:09   y2305   8622.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:47:09 and 当前时间 <=2023.01.09 11:42:29 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:47:47 and 当前时间 <=2023.01.09 11:43:07 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:48:25 and 当前时间 <=2023.01.09 11:43:45 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:49:03 and 当前时间 <=2023.01.09 11:44:23 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:49:41 and 当前时间 <=2023.01.09 11:45:01 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:50:19 and 当前时间 <=2023.01.09 11:45:39 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:50:57 and 当前时间 <=2023.01.09 11:46:17 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:51:35 and 当前时间 <=2023.01.09 11:46:55 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);
Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 11:27:48 CST)" was missed by 0:00:01.926576


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:52:13 and 当前时间 <=2023.01.09 11:47:33 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:52:51 and 当前时间 <=2023.01.09 11:48:11 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:53:29 and 当前时间 <=2023.01.09 11:48:49 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:54:07 and 当前时间 <=2023.01.09 11:49:27 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:54:45 and 当前时间 <=2023.01.09 11:50:05 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:55:23 and 当前时间 <=2023.01.09 11:50:43 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:56:01 and 当前时间 <=2023.01.09 11:51:21 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:56:39 and 当前时间 <=2023.01.09 11:51:59 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
更新完成
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:58:31 and 当前时间 <=2023.01.09 11:53:51 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:59:09 and 当前时间 <=2023.01.09 11:54:29 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 14:59:47 and 当前时间 <=2023.01.09 11:55:07 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 15:00:25 and 当前时间 <=2023.01.09 11:55:45 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 15:01:03 and 当前时间 <=2023.01.09 11:56:23 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);
Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 11:36:24 CST)" was missed by 0:00:02.442469


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 15:01:41 and 当前时间 <=2023.01.09 11:57:01 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 15:02:19 and 当前时间 <=2023.01.09 11:57:39 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 15:02:57 and 当前时间 <=2023.01.09 11:58:17 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 15:03:35 and 当前时间 <=2023.01.09 11:58:55 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 15:04:13 and 当前时间 <=2023.01.09 11:59:33 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);
sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 13:23:41 CST)" was missed by 0:00:09.235924
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
更新完成
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:48:12 and 当前时间 <=2023.01.09 13:43:32 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
ok
ok
'NoneType' object is not iterable
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:48:50 and 当前时间 <=2023.01.09 13:44:10 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:49:28 and 当前时间 <=2023.01.09 13:44:48 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
Empty DataFrame
Columns: [当前时间, 合约名称, 最新价, 操作]
Index: []
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:50:06 and 当前时间 <=2023.01.09 13:45:26 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
更新完成
cannot unpack non-iterable NoneType object
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:50:44 and 当前时间 <=2023.01.09 13:46:04 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:51:22 and 当前时间 <=2023.01.09 13:46:42 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:52:00 and 当前时间 <=2023.01.09 13:47:20 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:52:38 and 当前时间 <=2023.01.09 13:47:58 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:53:16 and 当前时间 <=2023.01.09 13:48:36 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:53:54 and 当前时间 <=2023.01.09 13:49:14 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:54:32 and 当前时间 <=2023.01.09 13:49:52 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:55:10 and 当前时间 <=2023.01.09 13:50:30 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:55:48 and 当前时间 <=2023.01.09 13:51:08 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);
Run time of job "自动回撤订单 (trigger: interval[0:02:05], next run at: 2023-01-09 13:33:18 CST)" was missed by 0:00:11.495608
Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 13:31:17 CST)" was missed by 0:00:07.503120
Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 13:31:41 CST)" was missed by 0:00:01.720166


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:56:26 and 当前时间 <=2023.01.09 13:51:46 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:57:04 and 当前时间 <=2023.01.09 13:52:24 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);
sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:58:26 and 当前时间 <=2023.01.09 13:53:46 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:33:16   AP305   8436.0  TODO
1   2023-01-09 13:31:36   RM301   3490.0  TODO
2   2023-01-09 13:33:14   c2305   2886.0  TODO
3   2023-01-09 13:33:16   i2305    820.5  TODO
4   2023-01-09 13:33:15   j2305   2722.0  TODO
5   2023-01-09 13:33:16  jd2305   4353.0  TODO
6   2023-01-09 13:33:16   l2305   7993.0  TODO
7   2023-01-09 13:33:16  lh2303  15770.0  TODO
8   2023-01-09 13:33:16   m2305   3817.0  TODO
9   2023-01-09 13:33:16  rb2305   4089.0  TODO
10  2023-01-09 13:33:16  sp2305   6476.0  TODO
11  2023-01-09 13:33:16   y2305   8626.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:59:04 and 当前时间 <=2023.01.09 13:54:24 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:34:29   AP305   8444.0  TODO
1   2023-01-09 13:31:36   RM301   3490.0  TODO
2   2023-01-09 13:34:28   c2305   2885.0  TODO
3   2023-01-09 13:34:29   i2305    823.0  TODO
4   2023-01-09 13:34:27   j2305   2724.5  TODO
5   2023-01-09 13:34:28  jd2305   4353.0  TODO
6   2023-01-09 13:34:29   l2305   7994.0  TODO
7   2023-01-09 13:34:29  lh2303  15770.0  TODO
8   2023-01-09 13:34:29   m2305   3816.0  TODO
9   2023-01-09 13:34:29  rb2305   4095.0  TODO
10  2023-01-09 13:34:29  sp2305   6474.0  TODO
11  2023-01-09 13:34:29   y2305   8632.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 16:59:42 and 当前时间 <=2023.01.09 13:55:02 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:35:20   AP305   8437.0  TODO
1   2023-01-09 13:35:20   c2305   2885.0  TODO
2   2023-01-09 13:35:20   i2305    822.5  TODO
3   2023-01-09 13:35:20   j2305   2721.5  TODO
4   2023-01-09 13:35:20  jd2305   4353.0  TODO
5   2023-01-09 13:35:20   l2305   7990.0  TODO
6   2023-01-09 13:35:19  lh2303  15760.0  TODO
7   2023-01-09 13:35:20   m2305   3815.0  TODO
8   2023-01-09 13:35:20  rb2305   4092.0  TODO
9   2023-01-09 13:35:20  sp2305   6468.0  TODO
10  2023-01-09 13:35:20   y2305   8622.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:00:20 and 当前时间 <=2023.01.09 13:55:40 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:35:45   AP305   8438.0  TODO
1   2023-01-09 13:35:46   c2305   2885.0  TODO
2   2023-01-09 13:35:46   i2305    822.5  TODO
3   2023-01-09 13:35:46   j2305   2722.5  TODO
4   2023-01-09 13:35:46  jd2305   4353.0  TODO
5   2023-01-09 13:35:46   l2305   7992.0  TODO
6   2023-01-09 13:35:46  lh2303  15760.0  TODO
7   2023-01-09 13:35:46   m2305   3816.0  TODO
8   2023-01-09 13:35:46  rb2305   4096.0  TODO
9   2023-01-09 13:35:46  sp2305   6474.0  TODO
10  2023-01-09 13:35:46   y2305   8624.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:00:58 and 当前时间 <=2023.01.09 13:56:18 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:36:36   AP305   8437.0  TODO
1   2023-01-09 13:36:31   c2305   2884.0  TODO
2   2023-01-09 13:36:36   i2305    822.5  TODO
3   2023-01-09 13:36:34   j2305   2722.0  TODO
4   2023-01-09 13:36:34  jd2305   4351.0  TODO
5   2023-01-09 13:36:36   l2305   7992.0  TODO
6   2023-01-09 13:36:34  lh2303  15760.0  TODO
7   2023-01-09 13:36:36   m2305   3815.0  TODO
8   2023-01-09 13:36:36  rb2305   4094.0  TODO
9   2023-01-09 13:36:36  sp2305   6470.0  TODO
10  2023-01-09 13:36:36   y2305   8622.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:01:36 and 当前时间 <=2023.01.09 13:56:56 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:37:02   AP305   8438.0  TODO
1   2023-01-09 13:37:02   c2305   2884.0  TODO
2   2023-01-09 13:37:02   i2305    822.5  TODO
3   2023-01-09 13:36:59   j2305   2722.5  TODO
4   2023-01-09 13:37:00  jd2305   4351.0  TODO
5   2023-01-09 13:37:02   l2305   7991.0  TODO
6   2023-01-09 13:37:02  lh2303  15730.0  TODO
7   2023-01-09 13:37:02   m2305   3815.0  TODO
8   2023-01-09 13:37:02  rb2305   4094.0  TODO
9   2023-01-09 13:37:01  sp2305   6468.0  TODO
10  2023-01-09 13:37:02   y2305   8628.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:02:14 and 当前时间 <=2023.01.09 13:57:34 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:37:52   AP305   8432.0  TODO
1   2023-01-09 13:37:51   c2305   2884.0  TODO
2   2023-01-09 13:37:52   i2305    822.5  TODO
3   2023-01-09 13:37:52   j2305   2722.0  TODO
4   2023-01-09 13:37:52  jd2305   4352.0  TODO
5   2023-01-09 13:37:52   l2305   7973.0  TODO
6   2023-01-09 13:37:52  lh2303  15725.0  TODO
7   2023-01-09 13:37:52   m2305   3815.0  TODO
8   2023-01-09 13:37:52  rb2305   4095.0  TODO
9   2023-01-09 13:37:52  sp2305   6468.0  TODO
10  2023-01-09 13:37:52   y2305   8624.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:02:52 and 当前时间 <=2023.01.09 13:58:12 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:38:17   AP305   8435.0  TODO
1   2023-01-09 13:38:18   c2305   2885.0  TODO
2   2023-01-09 13:38:18   i2305    822.5  TODO
3   2023-01-09 13:38:18   j2305   2721.5  TODO
4   2023-01-09 13:38:18  jd2305   4351.0  TODO
5   2023-01-09 13:38:18   l2305   7974.0  TODO
6   2023-01-09 13:38:17  lh2303  15735.0  TODO
7   2023-01-09 13:38:16   m2305   3815.0  TODO
8   2023-01-09 13:38:18  rb2305   4095.0  TODO
9   2023-01-09 13:38:18  sp2305   6468.0  TODO
10  2023-01-09 13:38:18   y2305   8624.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:03:30 and 当前时间 <=2023.01.09 13:58:50 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:39:08   AP305   8437.0  TODO
1   2023-01-09 13:39:09   c2305   2885.0  TODO
2   2023-01-09 13:39:09   i2305    822.5  TODO
3   2023-01-09 13:39:05   j2305   2720.0  TODO
4   2023-01-09 13:39:07  jd2305   4352.0  TODO
5   2023-01-09 13:39:09   l2305   7979.0  TODO
6   2023-01-09 13:39:09  lh2303  15695.0  TODO
7   2023-01-09 13:39:08   m2305   3816.0  TODO
8   2023-01-09 13:39:09  rb2305   4093.0  TODO
9   2023-01-09 13:39:09  sp2305   6468.0  TODO
10  2023-01-09 13:39:08   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:04:08 and 当前时间 <=2023.01.09 13:59:28 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成
pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:04:46 and 当前时间 <=2023.01.09 14:00:06 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:05:24 and 当前时间 <=2023.01.09 14:00:44 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:06:02 and 当前时间 <=2023.01.09 14:01:22 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:06:40 and 当前时间 <=2023.01.09 14:02:00 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:07:18 and 当前时间 <=2023.01.09 14:02:38 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:07:56 and 当前时间 <=2023.01.09 14:03:16 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:08:34 and 当前时间 <=2023.01.09 14:03:54 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
更新完成
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:10:39 and 当前时间 <=2023.01.09 14:05:59 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:45:10   AP305   8437.0  TODO
1   2023-01-09 13:45:09   c2305   2885.0  TODO
2   2023-01-09 13:45:10   i2305    823.5  TODO
3   2023-01-09 13:45:10   j2305   2723.5  TODO
4   2023-01-09 13:45:08  jd2305   4352.0  TODO
5   2023-01-09 13:45:10   l2305   7983.0  TODO
6   2023-01-09 13:45:10  lh2303  15680.0  TODO
7   2023-01-09 13:45:10   m2305   3816.0  TODO
8   2023-01-09 13:45:10  rb2305   4095.0  TODO
9   2023-01-09 13:45:10  sp2305   6466.0  TODO
10  2023-01-09 13:45:10   y2305   8620.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:11:17 and 当前时间 <=2023.01.09 14:06:37 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:47:02   AP305   8435.0  TODO
1   2023-01-09 13:47:04   c2305   2885.0  TODO
2   2023-01-09 13:47:04   i2305    823.0  TODO
3   2023-01-09 13:47:01   j2305   2719.5  TODO
4   2023-01-09 13:47:04  jd2305   4350.0  TODO
5   2023-01-09 13:47:04   l2305   7988.0  TODO
6   2023-01-09 13:47:04  lh2303  15675.0  TODO
7   2023-01-09 13:47:04   m2305   3815.0  TODO
8   2023-01-09 13:47:04  rb2305   4098.0  TODO
9   2023-01-09 13:47:04  sp2305   6470.0  TODO
10  2023-01-09 13:47:04   y2305   8622.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:11:55 and 当前时间 <=2023.01.09 14:07:15 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:47:29   AP305   8432.0  TODO
1   2023-01-09 13:47:29   c2305   2884.0  TODO
2   2023-01-09 13:47:29   i2305    823.0  TODO
3   2023-01-09 13:47:26   j2305   2721.5  TODO
4   2023-01-09 13:47:29  jd2305   4350.0  TODO
5   2023-01-09 13:47:29   l2305   7988.0  TODO
6   2023-01-09 13:47:29  lh2303  15685.0  TODO
7   2023-01-09 13:47:29   m2305   3815.0  TODO
8   2023-01-09 13:47:29  rb2305   4097.0  TODO
9   2023-01-09 13:47:29  sp2305   6470.0  TODO
10  2023-01-09 13:47:29   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:12:33 and 当前时间 <=2023.01.09 14:07:53 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:48:19   AP305   8427.0  TODO
1   2023-01-09 13:48:17   c2305   2884.0  TODO
2   2023-01-09 13:48:20   i2305    822.5  TODO
3   2023-01-09 13:48:15   j2305   2718.5  TODO
4   2023-01-09 13:48:18  jd2305   4350.0  TODO
5   2023-01-09 13:48:20   l2305   7990.0  TODO
6   2023-01-09 13:48:18  lh2303  15695.0  TODO
7   2023-01-09 13:48:19   m2305   3816.0  TODO
8   2023-01-09 13:48:20  rb2305   4095.0  TODO
9   2023-01-09 13:48:20  sp2305   6470.0  TODO
10  2023-01-09 13:48:19   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:13:11 and 当前时间 <=2023.01.09 14:08:31 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 13:48:45   AP305   8425.0  TODO
1   2023-01-09 13:48:45   c2305   2885.0  TODO
2   2023-01-09 13:48:45   i2305    822.5  TODO
3   2023-01-09 13:48:45   j2305   2719.0  TODO
4   2023-01-09 13:48:45  jd2305   4349.0  TODO
5   2023-01-09 13:48:45   l2305   7992.0  TODO
6   2023-01-09 13:48:45  lh2303  15700.0  TODO
7   2023-01-09 13:48:45   m2305   3815.0  TODO
8   2023-01-09 13:48:45  rb2305   4096.0  TODO
9   2023-01-09 13:48:45  sp2305   6472.0  TODO
10  2023-01-09 13:48:45   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:13:49 and 当前时间 <=2023.01.09 14:09:09 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:14:27 and 当前时间 <=2023.01.09 14:09:47 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:15:05 and 当前时间 <=2023.01.09 14:10:25 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:15:43 and 当前时间 <=2023.01.09 14:11:03 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:16:21 and 当前时间 <=2023.01.09 14:11:41 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:16:59 and 当前时间 <=2023.01.09 14:12:19 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:17:37 and 当前时间 <=2023.01.09 14:12:57 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:18:15 and 当前时间 <=2023.01.09 14:13:35 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:18:53 and 当前时间 <=2023.01.09 14:14:13 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:19:31 and 当前时间 <=2023.01.09 14:14:51 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:20:09 and 当前时间 <=2023.01.09 14:15:29 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:20:47 and 当前时间 <=2023.01.09 14:16:07 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:22:32 and 当前时间 <=2023.01.09 14:17:52 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:23:10 and 当前时间 <=2023.01.09 14:18:30 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:23:48 and 当前时间 <=2023.01.09 14:19:08 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:24:26 and 当前时间 <=2023.01.09 14:19:46 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
更新完成
cannot unpack non-iterable NoneType object
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:25:04 and 当前时间 <=2023.01.09 14:20:24 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:25:42 and 当前时间 <=2023.01.09 14:21:02 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:26:20 and 当前时间 <=2023.01.09 14:21:40 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:26:58 and 当前时间 <=2023.01.09 14:22:18 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:27:36 and 当前时间 <=2023.01.09 14:22:56 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:28:14 and 当前时间 <=2023.01.09 14:23:34 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
更新完成
cannot unpack non-iterable NoneType object
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:28:52 and 当前时间 <=2023.01.09 14:24:12 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
更新完成
start qry thread
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:30:36 and 当前时间 <=2023.01.09 14:25:56 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:05:05   AP305   8435.0  TODO
1   2023-01-09 14:05:03   c2305   2885.0  TODO
2   2023-01-09 14:05:05   i2305    822.5  TODO
3   2023-01-09 14:05:04   j2305   2720.0  TODO
4   2023-01-09 14:05:05  jd2305   4352.0  TODO
5   2023-01-09 14:05:05   l2305   7997.0  TODO
6   2023-01-09 14:05:05  lh2303  15720.0  TODO
7   2023-01-09 14:05:05   m2305   3813.0  TODO
8   2023-01-09 14:05:05  rb2305   4092.0  TODO
9   2023-01-09 14:05:05  sp2305   6466.0  TODO
10  2023-01-09 14:05:05   y2305   8628.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:31:14 and 当前时间 <=2023.01.09 14:26:34 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:06:39   AP305   8441.0  TODO
1   2023-01-09 14:06:38   c2305   2885.0  TODO
2   2023-01-09 14:06:39   i2305    822.5  TODO
3   2023-01-09 14:06:39   j2305   2719.0  TODO
4   2023-01-09 14:06:39  jd2305   4350.0  TODO
5   2023-01-09 14:06:39   l2305   8000.0  TODO
6   2023-01-09 14:06:38  lh2303  15730.0  TODO
7   2023-01-09 14:06:39   m2305   3813.0  TODO
8   2023-01-09 14:06:39  rb2305   4092.0  TODO
9   2023-01-09 14:06:39  sp2305   6466.0  TODO
10  2023-01-09 14:06:39   y2305   8624.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:31:52 and 当前时间 <=2023.01.09 14:27:12 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:07:30   AP305   8441.0  TODO
1   2023-01-09 14:07:25   c2305   2885.0  TODO
2   2023-01-09 14:07:31   i2305    823.0  TODO
3   2023-01-09 14:07:27   j2305   2720.0  TODO
4   2023-01-09 14:07:28  jd2305   4350.0  TODO
5   2023-01-09 14:07:31   l2305   8003.0  TODO
6   2023-01-09 14:07:27  lh2303  15720.0  TODO
7   2023-01-09 14:07:30   m2305   3814.0  TODO
8   2023-01-09 14:07:31  rb2305   4093.0  TODO
9   2023-01-09 14:07:31  sp2305   6462.0  TODO
10  2023-01-09 14:07:31   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:32:30 and 当前时间 <=2023.01.09 14:27:50 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 14:08:29 CST)" was missed by 0:00:01.025214


select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:07:56   AP305   8439.0  TODO
1   2023-01-09 14:07:56   c2305   2884.0  TODO
2   2023-01-09 14:07:56   i2305    822.5  TODO
3   2023-01-09 14:07:54   j2305   2721.0  TODO
4   2023-01-09 14:07:54  jd2305   4350.0  TODO
5   2023-01-09 14:07:56   l2305   8004.0  TODO
6   2023-01-09 14:07:49  lh2303  15730.0  TODO
7   2023-01-09 14:07:56   m2305   3813.0  TODO
8   2023-01-09 14:07:56  rb2305   4093.0  TODO
9   2023-01-09 14:07:56  sp2305   6462.0  TODO
10  2023-01-09 14:07:56   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:33:08 and 当前时间 <=2023.01.09 14:28:28 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:08:47   AP305   8436.0  TODO
1   2023-01-09 14:08:39   c2305   2885.0  TODO
2   2023-01-09 14:08:47   i2305    822.5  TODO
3   2023-01-09 14:08:46   j2305   2720.0  TODO
4   2023-01-09 14:08:46  jd2305   4348.0  TODO
5   2023-01-09 14:08:47   l2305   8005.0  TODO
6   2023-01-09 14:08:46  lh2303  15735.0  TODO
7   2023-01-09 14:08:47   m2305   3813.0  TODO
8   2023-01-09 14:08:47  rb2305   4094.0  TODO
9   2023-01-09 14:08:47  sp2305   6462.0  TODO
10  2023-01-09 14:08:47   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:33:46 and 当前时间 <=2023.01.09 14:29:06 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:09:12   AP305   8437.0  TODO
1   2023-01-09 14:09:12   RM301   3490.0  TODO
2   2023-01-09 14:09:10   c2305   2885.0  TODO
3   2023-01-09 14:09:12   i2305    822.5  TODO
4   2023-01-09 14:09:12   j2305   2720.5  TODO
5   2023-01-09 14:09:11  jd2305   4348.0  TODO
6   2023-01-09 14:09:12   l2305   8007.0  TODO
7   2023-01-09 14:09:11  lh2303  15720.0  TODO
8   2023-01-09 14:09:12   m2305   3814.0  TODO
9   2023-01-09 14:09:12  rb2305   4094.0  TODO
10  2023-01-09 14:09:12  sp2305   6462.0  TODO
11  2023-01-09 14:09:12   y2305   8628.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:34:24 and 当前时间 <=2023.01.09 14:29:44 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:10:03   AP305   8439.0  TODO
1   2023-01-09 14:09:12   RM301   3490.0  TODO
2   2023-01-09 14:10:03   c2305   2884.0  TODO
3   2023-01-09 14:10:03   i2305    823.0  TODO
4   2023-01-09 14:10:03   j2305   2719.0  TODO
5   2023-01-09 14:10:02  jd2305   4349.0  TODO
6   2023-01-09 14:10:03   l2305   8008.0  TODO
7   2023-01-09 14:10:01  lh2303  15730.0  TODO
8   2023-01-09 14:10:03   m2305   3815.0  TODO
9   2023-01-09 14:10:03  rb2305   4092.0  TODO
10  2023-01-09 14:10:03  sp2305   6466.0  TODO
11  2023-01-09 14:10:03   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:35:02 and 当前时间 <=2023.01.09 14:30:22 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:10:28   AP305   8444.0  TODO
1   2023-01-09 14:09:12   RM301   3490.0  TODO
2   2023-01-09 14:10:28   c2305   2885.0  TODO
3   2023-01-09 14:10:28   i2305    822.5  TODO
4   2023-01-09 14:10:28   j2305   2718.0  TODO
5   2023-01-09 14:10:28  jd2305   4347.0  TODO
6   2023-01-09 14:10:28   l2305   8008.0  TODO
7   2023-01-09 14:10:18  lh2303  15735.0  TODO
8   2023-01-09 14:10:28   m2305   3816.0  TODO
9   2023-01-09 14:10:28  rb2305   4091.0  TODO
10  2023-01-09 14:10:28  sp2305   6466.0  TODO
11  2023-01-09 14:10:28   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:35:40 and 当前时间 <=2023.01.09 14:31:00 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:11:19   AP305   8440.0  TODO
1   2023-01-09 14:11:03   RM301   3490.0  TODO
2   2023-01-09 14:11:18   c2305   2884.0  TODO
3   2023-01-09 14:11:19   i2305    821.5  TODO
4   2023-01-09 14:11:19   j2305   2716.0  TODO
5   2023-01-09 14:11:19  jd2305   4349.0  TODO
6   2023-01-09 14:11:19   l2305   8003.0  TODO
7   2023-01-09 14:11:15  lh2303  15725.0  TODO
8   2023-01-09 14:11:19   m2305   3815.0  TODO
9   2023-01-09 14:11:19  rb2305   4089.0  TODO
10  2023-01-09 14:11:19  sp2305   6464.0  TODO
11  2023-01-09 14:11:19   y2305   8622.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:36:18 and 当前时间 <=2023.01.09 14:31:38 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:11:44   AP305   8436.0  TODO
1   2023-01-09 14:11:03   RM301   3490.0  TODO
2   2023-01-09 14:11:35   c2305   2884.0  TODO
3   2023-01-09 14:11:45   i2305    822.0  TODO
4   2023-01-09 14:11:35   j2305   2716.5  TODO
5   2023-01-09 14:11:42  jd2305   4350.0  TODO
6   2023-01-09 14:11:45   l2305   8004.0  TODO
7   2023-01-09 14:11:45  lh2303  15730.0  TODO
8   2023-01-09 14:11:44   m2305   3814.0  TODO
9   2023-01-09 14:11:45  rb2305   4090.0  TODO
10  2023-01-09 14:11:44  sp2305   6466.0  TODO
11  2023-01-09 14:11:45   y2305   8622.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:36:56 and 当前时间 <=2023.01.09 14:32:16 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:12:36   AP305   8440.0  TODO
1   2023-01-09 14:11:03   RM301   3490.0  TODO
2   2023-01-09 14:12:36   c2305   2884.0  TODO
3   2023-01-09 14:12:36   i2305    821.0  TODO
4   2023-01-09 14:12:34   j2305   2716.5  TODO
5   2023-01-09 14:12:35  jd2305   4349.0  TODO
6   2023-01-09 14:12:36   l2305   8003.0  TODO
7   2023-01-09 14:12:34  lh2303  15725.0  TODO
8   2023-01-09 14:12:36   m2305   3814.0  TODO
9   2023-01-09 14:12:36  rb2305   4089.0  TODO
10  2023-01-09 14:12:36  sp2305   6462.0  TODO
11  2023-01-09 14:12:36   y2305   8622.0  TODOsh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
更新完成
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:38:23 and 当前时间 <=2023.01.09 14:33:43 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:13:26   AP305   8441.0  TODO
1   2023-01-09 14:11:03   RM301   3490.0  TODO
2   2023-01-09 14:13:26   c2305   2884.0  TODO
3   2023-01-09 14:13:26   i2305    821.5  TODO
4   2023-01-09 14:13:26   j2305   2717.0  TODO
5   2023-01-09 14:13:24  jd2305   4350.0  TODO
6   2023-01-09 14:13:26   l2305   8003.0  TODO
7   2023-01-09 14:13:24  lh2303  15720.0  TODO
8   2023-01-09 14:13:26   m2305   3811.0  TODO
9   2023-01-09 14:13:26  rb2305   4090.0  TODO
10  2023-01-09 14:13:26  sp2305   6464.0  TODO
11  2023-01-09 14:13:26   y2305   8618.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:39:01 and 当前时间 <=2023.01.09 14:34:21 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:14:45   AP305   8438.0  TODO
1   2023-01-09 14:14:35   c2305   2884.0  TODO
2   2023-01-09 14:14:45   i2305    822.0  TODO
3   2023-01-09 14:14:37   j2305   2716.0  TODO
4   2023-01-09 14:14:45  jd2305   4350.0  TODO
5   2023-01-09 14:14:45   l2305   8002.0  TODO
6   2023-01-09 14:14:41  lh2303  15720.0  TODO
7   2023-01-09 14:14:45   m2305   3811.0  TODO
8   2023-01-09 14:14:45  rb2305   4092.0  TODO
9   2023-01-09 14:14:45  sp2305   6466.0  TODO
10  2023-01-09 14:14:45   y2305   8624.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:39:39 and 当前时间 <=2023.01.09 14:34:59 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:15:11   AP305   8431.0  TODO
1   2023-01-09 14:15:10   c2305   2884.0  TODO
2   2023-01-09 14:15:11   i2305    821.5  TODO
3   2023-01-09 14:15:08   j2305   2716.0  TODO
4   2023-01-09 14:15:09  jd2305   4350.0  TODO
5   2023-01-09 14:15:11   l2305   8000.0  TODO
6   2023-01-09 14:15:11  lh2303  15720.0  TODO
7   2023-01-09 14:15:11   m2305   3811.0  TODO
8   2023-01-09 14:15:11  rb2305   4090.0  TODO
9   2023-01-09 14:15:11  sp2305   6464.0  TODO
10  2023-01-09 14:15:11   y2305   8624.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:40:17 and 当前时间 <=2023.01.09 14:35:37 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:16:01   AP305   8435.0  TODO
1   2023-01-09 14:16:00   c2305   2884.0  TODO
2   2023-01-09 14:16:01   i2305    821.5  TODO
3   2023-01-09 14:16:01   j2305   2713.5  TODO
4   2023-01-09 14:15:59  jd2305   4350.0  TODO
5   2023-01-09 14:16:01   l2305   7997.0  TODO
6   2023-01-09 14:16:01  lh2303  15710.0  TODO
7   2023-01-09 14:16:01   m2305   3812.0  TODO
8   2023-01-09 14:16:01  rb2305   4089.0  TODO
9   2023-01-09 14:16:01  sp2305   6468.0  TODO
10  2023-01-09 14:16:01   y2305   8616.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:40:55 and 当前时间 <=2023.01.09 14:36:15 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);

更新完成

    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:16:25   AP305   8436.0  TODO
1   2023-01-09 14:16:23   c2305   2885.0  TODO
2   2023-01-09 14:16:27   i2305    822.0  TODO
3   2023-01-09 14:16:26   j2305   2713.5  TODO
4   2023-01-09 14:16:27  jd2305   4350.0  TODO
5   2023-01-09 14:16:27   l2305   8000.0  TODO
6   2023-01-09 14:16:26  lh2303  15700.0  TODO
7   2023-01-09 14:16:27   m2305   3812.0  TODO
8   2023-01-09 14:16:27  rb2305   4092.0  TODO
9   2023-01-09 14:16:27  sp2305   6472.0  TODO
10  2023-01-09 14:16:27   y2305   8620.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:41:33 and 当前时间 <=2023.01.09 14:36:53 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:17:16   AP305   8440.0  TODO
1   2023-01-09 14:17:15   c2305   2884.0  TODO
2   2023-01-09 14:17:17   i2305    822.0  TODO
3   2023-01-09 14:17:16   j2305   2713.5  TODO
4   2023-01-09 14:17:12  jd2305   4350.0  TODO
5   2023-01-09 14:17:17   l2305   8000.0  TODO
6   2023-01-09 14:17:17  lh2303  15715.0  TODO
7   2023-01-09 14:17:17   m2305   3812.0  TODO
8   2023-01-09 14:17:17  rb2305   4092.0  TODO
9   2023-01-09 14:17:17  sp2305   6468.0  TODO
10  2023-01-09 14:17:17   y2305   8626.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:42:11 and 当前时间 <=2023.01.09 14:37:31 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:17:43   AP305   8442.0  TODO
1   2023-01-09 14:17:39   c2305   2885.0  TODO
2   2023-01-09 14:17:42   i2305    822.0  TODO
3   2023-01-09 14:17:31   j2305   2713.5  TODO
4   2023-01-09 14:17:36  jd2305   4350.0  TODO
5   2023-01-09 14:17:43   l2305   8001.0  TODO
6   2023-01-09 14:17:42  lh2303  15715.0  TODO
7   2023-01-09 14:17:43   m2305   3813.0  TODO
8   2023-01-09 14:17:43  rb2305   4091.0  TODO
9   2023-01-09 14:17:43  sp2305   6466.0  TODO
10  2023-01-09 14:17:43   y2305   8628.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:42:49 and 当前时间 <=2023.01.09 14:38:09 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);
sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:43:53 and 当前时间 <=2023.01.09 14:39:13 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:18:32   AP305   8441.0  TODO
1   2023-01-09 14:18:27   c2305   2885.0  TODO
2   2023-01-09 14:18:34   i2305    821.5  TODO
3   2023-01-09 14:18:32   j2305   2713.5  TODO
4   2023-01-09 14:18:27  jd2305   4349.0  TODO
5   2023-01-09 14:18:29   l2305   8001.0  TODO
6   2023-01-09 14:18:22  lh2303  15710.0  TODO
7   2023-01-09 14:18:34   m2305   3815.0  TODO
8   2023-01-09 14:18:34  rb2305   4090.0  TODO
9   2023-01-09 14:18:34  sp2305   6464.0  TODO
10  2023-01-09 14:18:34   y2305   8630.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:44:31 and 当前时间 <=2023.01.09 14:39:51 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:19:54   AP305   8437.0  TODO
1   2023-01-09 14:19:55   c2305   2884.0  TODO
2   2023-01-09 14:19:55   i2305    821.0  TODO
3   2023-01-09 14:19:55   j2305   2710.5  TODO
4   2023-01-09 14:19:54  jd2305   4350.0  TODO
5   2023-01-09 14:19:55   l2305   8000.0  TODO
6   2023-01-09 14:19:49  lh2303  15710.0  TODO
7   2023-01-09 14:19:55   m2305   3815.0  TODO
8   2023-01-09 14:19:55  rb2305   4088.0  TODO
9   2023-01-09 14:19:54  sp2305   6466.0  TODO
10  2023-01-09 14:19:55   y2305   8628.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:45:09 and 当前时间 <=2023.01.09 14:40:29 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);
sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:46:23 and 当前时间 <=2023.01.09 14:41:43 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:21:13   AP305   8433.0  TODO
1   2023-01-09 14:21:09   c2305   2884.0  TODO
2   2023-01-09 14:21:13   i2305    821.5  TODO
3   2023-01-09 14:21:13   j2305   2709.5  TODO
4   2023-01-09 14:21:08  jd2305   4348.0  TODO
5   2023-01-09 14:21:13   l2305   7994.0  TODO
6   2023-01-09 14:21:09  lh2303  15720.0  TODO
7   2023-01-09 14:21:13   m2305   3814.0  TODO
8   2023-01-09 14:21:13  rb2305   4088.0  TODO
9   2023-01-09 14:21:13  sp2305   6460.0  TODO
10  2023-01-09 14:21:13   y2305   8620.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:47:01 and 当前时间 <=2023.01.09 14:42:21 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:22:22   AP305   8436.0  TODO
1   2023-01-09 14:22:27   c2305   2883.0  TODO
2   2023-01-09 14:22:28   i2305    822.0  TODO
3   2023-01-09 14:22:26   j2305   2712.0  TODO
4   2023-01-09 14:22:23  jd2305   4349.0  TODO
5   2023-01-09 14:22:28   l2305   7994.0  TODO
6   2023-01-09 14:22:27  lh2303  15715.0  TODO
7   2023-01-09 14:22:28   m2305   3814.0  TODO
8   2023-01-09 14:22:28  rb2305   4091.0  TODO
9   2023-01-09 14:22:28  sp2305   6440.0  TODO
10  2023-01-09 14:22:28   y2305   8628.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:47:39 and 当前时间 <=2023.01.09 14:42:59 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:23:19   AP305   8439.0  TODO
1   2023-01-09 14:23:16   c2305   2883.0  TODO
2   2023-01-09 14:23:19   i2305    821.5  TODO
3   2023-01-09 14:23:19   j2305   2711.0  TODO
4   2023-01-09 14:23:17  jd2305   4348.0  TODO
5   2023-01-09 14:23:18   l2305   7993.0  TODO
6   2023-01-09 14:23:17  lh2303  15690.0  TODO
7   2023-01-09 14:23:18   m2305   3814.0  TODO
8   2023-01-09 14:23:19  rb2305   4090.0  TODO
9   2023-01-09 14:23:19  sp2305   6450.0  TODO
10  2023-01-09 14:23:19   y2305   8630.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:48:17 and 当前时间 <=2023.01.09 14:43:37 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:23:43   AP305   8439.0  TODO
1   2023-01-09 14:23:43   c2305   2883.0  TODO
2   2023-01-09 14:23:44   i2305    821.5  TODO
3   2023-01-09 14:23:44   j2305   2710.0  TODO
4   2023-01-09 14:23:42  jd2305   4350.0  TODO
5   2023-01-09 14:23:44   l2305   7994.0  TODO
6   2023-01-09 14:23:44  lh2303  15680.0  TODO
7   2023-01-09 14:23:44   m2305   3814.0  TODO
8   2023-01-09 14:23:44  rb2305   4087.0  TODO
9   2023-01-09 14:23:44  sp2305   6446.0  TODO
10  2023-01-09 14:23:44   y2305   8632.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:48:55 and 当前时间 <=2023.01.09 14:44:15 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:24:32   AP305   8438.0  TODO
1   2023-01-09 14:24:33   c2305   2884.0  TODO
2   2023-01-09 14:24:35   i2305    820.0  TODO
3   2023-01-09 14:24:32   j2305   2708.5  TODO
4   2023-01-09 14:24:35  jd2305   4350.0  TODO
5   2023-01-09 14:24:35   l2305   7990.0  TODO
6   2023-01-09 14:24:33  lh2303  15690.0  TODO
7   2023-01-09 14:24:35   m2305   3812.0  TODO
8   2023-01-09 14:24:35  rb2305   4086.0  TODO
9   2023-01-09 14:24:35  sp2305   6444.0  TODO
10  2023-01-09 14:24:35   y2305   8630.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:49:33 and 当前时间 <=2023.01.09 14:44:53 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:24:54   AP305   8437.0  TODO
1   2023-01-09 14:24:59   c2305   2883.0  TODO
2   2023-01-09 14:25:00   i2305    820.5  TODO
3   2023-01-09 14:25:00   j2305   2708.5  TODO
4   2023-01-09 14:25:00  jd2305   4351.0  TODO
5   2023-01-09 14:25:00   l2305   7992.0  TODO
6   2023-01-09 14:25:00  lh2303  15700.0  TODO
7   2023-01-09 14:25:00   m2305   3812.0  TODO
8   2023-01-09 14:25:00  rb2305   4087.0  TODO
9   2023-01-09 14:25:00  sp2305   6442.0  TODO
10  2023-01-09 14:25:00   y2305   8634.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:50:11 and 当前时间 <=2023.01.09 14:45:31 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:25:48   AP305   8436.0  TODO
1   2023-01-09 14:25:51   c2305   2884.0  TODO
2   2023-01-09 14:25:51   i2305    820.5  TODO
3   2023-01-09 14:25:51   j2305   2710.0  TODO
4   2023-01-09 14:25:49  jd2305   4351.0  TODO
5   2023-01-09 14:25:51   l2305   7989.0  TODO
6   2023-01-09 14:25:51  lh2303  15690.0  TODO
7   2023-01-09 14:25:51   m2305   3811.0  TODO
8   2023-01-09 14:25:51  rb2305   4088.0  TODO
9   2023-01-09 14:25:51  sp2305   6436.0  TODO
10  2023-01-09 14:25:51   y2305   8636.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:50:49 and 当前时间 <=2023.01.09 14:46:09 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:26:17   AP305   8436.0  TODO
1   2023-01-09 14:26:15   c2305   2883.0  TODO
2   2023-01-09 14:26:16   i2305    821.0  TODO
3   2023-01-09 14:26:17   j2305   2710.0  TODO
4   2023-01-09 14:26:13  jd2305   4351.0  TODO
5   2023-01-09 14:26:16   l2305   7991.0  TODO
6   2023-01-09 14:26:15  lh2303  15690.0  TODO
7   2023-01-09 14:26:17   m2305   3811.0  TODO
8   2023-01-09 14:26:16  rb2305   4087.0  TODO
9   2023-01-09 14:26:16  sp2305   6438.0  TODO
10  2023-01-09 14:26:17   y2305   8634.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:51:27 and 当前时间 <=2023.01.09 14:46:47 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:27:04   AP305   8434.0  TODO
1   2023-01-09 14:27:07   c2305   2883.0  TODO
2   2023-01-09 14:27:08   i2305    819.5  TODO
3   2023-01-09 14:27:04   j2305   2709.5  TODO
4   2023-01-09 14:27:06  jd2305   4350.0  TODO
5   2023-01-09 14:27:08   l2305   7990.0  TODO
6   2023-01-09 14:27:08  lh2303  15685.0  TODO
7   2023-01-09 14:27:07   m2305   3812.0  TODO
8   2023-01-09 14:27:08  rb2305   4088.0  TODO
9   2023-01-09 14:27:08  sp2305   6436.0  TODO
10  2023-01-09 14:27:08   y2305   8628.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:52:05 and 当前时间 <=2023.01.09 14:47:25 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:27:33   AP305   8432.0  TODO
1   2023-01-09 14:27:21   c2305   2883.0  TODO
2   2023-01-09 14:27:33   i2305    819.5  TODO
3   2023-01-09 14:27:31   j2305   2709.0  TODO
4   2023-01-09 14:27:33  jd2305   4351.0  TODO
5   2023-01-09 14:27:33   l2305   7992.0  TODO
6   2023-01-09 14:27:33  lh2303  15700.0  TODO
7   2023-01-09 14:27:33   m2305   3811.0  TODO
8   2023-01-09 14:27:33  rb2305   4088.0  TODO
9   2023-01-09 14:27:33  sp2305   6436.0  TODO
10  2023-01-09 14:27:33   y2305   8632.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:52:43 and 当前时间 <=2023.01.09 14:48:03 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:28:24   AP305   8432.0  TODO
1   2023-01-09 14:28:23   c2305   2884.0  TODO
2   2023-01-09 14:28:24   i2305    819.5  TODO
3   2023-01-09 14:28:23   j2305   2711.0  TODO
4   2023-01-09 14:28:24  jd2305   4351.0  TODO
5   2023-01-09 14:28:24   l2305   7990.0  TODO
6   2023-01-09 14:28:22  lh2303  15700.0  TODO
7   2023-01-09 14:28:24   m2305   3811.0  TODO
8   2023-01-09 14:28:24  rb2305   4088.0  TODO
9   2023-01-09 14:28:24  sp2305   6434.0  TODO
10  2023-01-09 14:28:24   y2305   8634.0  TODORun time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 14:28:16 CST)" was missed by 0:00:01.276513
sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:54:23 and 当前时间 <=2023.01.09 14:49:43 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:29:15   AP305   8434.0  TODO
1   2023-01-09 14:29:15   c2305   2883.0  TODO
2   2023-01-09 14:29:15   i2305    819.5  TODO
3   2023-01-09 14:29:15   j2305   2710.0  TODO
4   2023-01-09 14:29:15  jd2305   4352.0  TODO
5   2023-01-09 14:29:15   l2305   7990.0  TODO
6   2023-01-09 14:29:15  lh2303  15700.0  TODO
7   2023-01-09 14:29:15   m2305   3810.0  TODO
8   2023-01-09 14:29:15  rb2305   4088.0  TODO
9   2023-01-09 14:29:15  sp2305   6438.0  TODO
10  2023-01-09 14:29:15   y2305   8634.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:55:01 and 当前时间 <=2023.01.09 14:50:21 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:30:49   AP305   8417.0  TODO
1   2023-01-09 14:30:49   c2305   2884.0  TODO
2   2023-01-09 14:30:49   i2305    819.5  TODO
3   2023-01-09 14:30:49   j2305   2713.5  TODO
4   2023-01-09 14:30:46  jd2305   4351.0  TODO
5   2023-01-09 14:30:49   l2305   7988.0  TODO
6   2023-01-09 14:30:49  lh2303  15700.0  TODO
7   2023-01-09 14:30:49   m2305   3812.0  TODO
8   2023-01-09 14:30:49  rb2305   4085.0  TODO
9   2023-01-09 14:30:49  sp2305   6432.0  TODO
10  2023-01-09 14:30:49   y2305   8632.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:55:39 and 当前时间 <=2023.01.09 14:50:59 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:31:14   AP305   8422.0  TODO
1   2023-01-09 14:31:10   c2305   2883.0  TODO
2   2023-01-09 14:31:15   i2305    819.5  TODO
3   2023-01-09 14:31:10   j2305   2713.5  TODO
4   2023-01-09 14:31:14  jd2305   4352.0  TODO
5   2023-01-09 14:31:14   l2305   7988.0  TODO
6   2023-01-09 14:31:14  lh2303  15695.0  TODO
7   2023-01-09 14:31:14   m2305   3812.0  TODO
8   2023-01-09 14:31:14  rb2305   4085.0  TODO
9   2023-01-09 14:31:14  sp2305   6430.0  TODO
10  2023-01-09 14:31:14   y2305   8632.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:56:17 and 当前时间 <=2023.01.09 14:51:37 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:32:05   AP305   8415.0  TODO
1   2023-01-09 14:32:03   c2305   2883.0  TODO
2   2023-01-09 14:32:05   i2305    820.0  TODO
3   2023-01-09 14:31:58   j2305   2712.0  TODO
4   2023-01-09 14:32:02  jd2305   4351.0  TODO
5   2023-01-09 14:32:05   l2305   7991.0  TODO
6   2023-01-09 14:32:04  lh2303  15695.0  TODO
7   2023-01-09 14:32:05   m2305   3812.0  TODO
8   2023-01-09 14:32:05  rb2305   4084.0  TODO
9   2023-01-09 14:32:05  sp2305   6430.0  TODO
10  2023-01-09 14:32:05   y2305   8634.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:56:55 and 当前时间 <=2023.01.09 14:52:15 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:32:30   AP305   8409.0  TODO
1   2023-01-09 14:32:28   c2305   2885.0  TODO
2   2023-01-09 14:32:31   i2305    820.0  TODO
3   2023-01-09 14:32:29   j2305   2716.0  TODO
4   2023-01-09 14:32:29  jd2305   4351.0  TODO
5   2023-01-09 14:32:31   l2305   7995.0  TODO
6   2023-01-09 14:32:31  lh2303  15700.0  TODO
7   2023-01-09 14:32:31   m2305   3814.0  TODO
8   2023-01-09 14:32:30  rb2305   4087.0  TODO
9   2023-01-09 14:32:30  sp2305   6430.0  TODO
10  2023-01-09 14:32:31   y2305   8638.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:57:33 and 当前时间 <=2023.01.09 14:52:53 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:33:22   AP305   8401.0  TODO
1   2023-01-09 14:33:08   c2305   2885.0  TODO
2   2023-01-09 14:33:22   i2305    821.0  TODO
3   2023-01-09 14:33:22   j2305   2717.0  TODO
4   2023-01-09 14:33:21  jd2305   4350.0  TODO
5   2023-01-09 14:33:22   l2305   7996.0  TODO
6   2023-01-09 14:33:17  lh2303  15695.0  TODO
7   2023-01-09 14:33:22   m2305   3813.0  TODO
8   2023-01-09 14:33:22  rb2305   4090.0  TODO
9   2023-01-09 14:33:22  sp2305   6428.0  TODO
10  2023-01-09 14:33:22   y2305   8634.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:58:11 and 当前时间 <=2023.01.09 14:53:31 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:33:47   AP305   8389.0  TODO
1   2023-01-09 14:33:42   c2305   2884.0  TODO
2   2023-01-09 14:33:47   i2305    821.5  TODO
3   2023-01-09 14:33:46   j2305   2719.0  TODO
4   2023-01-09 14:33:44  jd2305   4350.0  TODO
5   2023-01-09 14:33:46   l2305   7994.0  TODO
6   2023-01-09 14:33:47  lh2303  15690.0  TODO
7   2023-01-09 14:33:46   m2305   3812.0  TODO
8   2023-01-09 14:33:47  rb2305   4090.0  TODO
9   2023-01-09 14:33:47  sp2305   6430.0  TODO
10  2023-01-09 14:33:47   y2305   8632.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:58:49 and 当前时间 <=2023.01.09 14:54:09 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 17:59:27 and 当前时间 <=2023.01.09 14:54:47 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:00:05 and 当前时间 <=2023.01.09 14:55:25 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:00:43 and 当前时间 <=2023.01.09 14:56:03 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
更新完成
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:02:34 and 当前时间 <=2023.01.09 14:57:54 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:03:12 and 当前时间 <=2023.01.09 14:58:32 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:03:50 and 当前时间 <=2023.01.09 14:59:10 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:04:28 and 当前时间 <=2023.01.09 14:59:48 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:05:06 and 当前时间 <=2023.01.09 15:00:26 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    更新完成

tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:05:44 and 当前时间 <=2023.01.09 15:01:04 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:06:22 and 当前时间 <=2023.01.09 15:01:42 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:07:00 and 当前时间 <=2023.01.09 15:02:20 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:07:38 and 当前时间 <=2023.01.09 15:02:58 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:08:16 and 当前时间 <=2023.01.09 15:03:36 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    
tq.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:08:54 and 当前时间 <=2023.01.09 15:04:14 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
tick_CCI_BOLL_k上下突破.exit()
qry instrument
sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:12:13 and 当前时间 <=2023.01.09 15:07:33 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:45:20   AP305   8434.0  TODO
1   2023-01-09 14:45:16   c2305   2882.0  TODO
2   2023-01-09 14:45:20   i2305    819.5  TODO
3   2023-01-09 14:45:20   j2305   2719.5  TODO
4   2023-01-09 14:45:16  jd2305   4350.0  TODO
5   2023-01-09 14:45:20   l2305   7998.0  TODO
6   2023-01-09 14:45:20  lh2303  15695.0  TODO
7   2023-01-09 14:45:19   m2305   3810.0  TODO
8   2023-01-09 14:45:20  rb2305   4086.0  TODO
9   2023-01-09 14:45:20  sp2305   6432.0  TODO
10  2023-01-09 14:45:20   y2305   8626.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:12:51 and 当前时间 <=2023.01.09 15:08:11 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:48:16   AP305   8441.0  TODO
1   2023-01-09 14:48:15   c2305   2884.0  TODO
2   2023-01-09 14:48:16   i2305    821.0  TODO
3   2023-01-09 14:48:16   j2305   2722.0  TODO
4   2023-01-09 14:48:15  jd2305   4354.0  TODO
5   2023-01-09 14:48:15   l2305   8001.0  TODO
6   2023-01-09 14:48:16  lh2303  15695.0  TODO
7   2023-01-09 14:48:16   m2305   3813.0  TODO
8   2023-01-09 14:48:16  rb2305   4090.0  TODO
9   2023-01-09 14:48:16  sp2305   6428.0  TODO
10  2023-01-09 14:48:16   y2305   8624.0  TODO
更新完成
'NoneType' object is not iterable
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:13:29 and 当前时间 <=2023.01.09 15:08:49 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:49:12   AP305   8442.0  TODO
1   2023-01-09 14:49:11   c2305   2885.0  TODO
2   2023-01-09 14:49:12   i2305    821.5  TODO
3   2023-01-09 14:49:12   j2305   2723.0  TODO
4   2023-01-09 14:49:11  jd2305   4355.0  TODO
5   2023-01-09 14:49:12   l2305   8004.0  TODO
6   2023-01-09 14:49:12  lh2303  15735.0  TODO
7   2023-01-09 14:49:12   m2305   3812.0  TODO
8   2023-01-09 14:49:12  rb2305   4089.0  TODO
9   2023-01-09 14:49:12  sp2305   6424.0  TODO
10  2023-01-09 14:49:12   y2305   8622.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:14:07 and 当前时间 <=2023.01.09 15:09:27 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:49:38   AP305   8447.0  TODO
1   2023-01-09 14:49:38   c2305   2885.0  TODO
2   2023-01-09 14:49:39   i2305    821.5  TODO
3   2023-01-09 14:49:38   j2305   2723.5  TODO
4   2023-01-09 14:49:38  jd2305   4355.0  TODO
5   2023-01-09 14:49:39   l2305   8004.0  TODO
6   2023-01-09 14:49:39  lh2303  15720.0  TODO
7   2023-01-09 14:49:39   m2305   3813.0  TODO
8   2023-01-09 14:49:39  rb2305   4090.0  TODO
9   2023-01-09 14:49:39  sp2305   6426.0  TODO
10  2023-01-09 14:49:38   y2305   8624.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:14:45 and 当前时间 <=2023.01.09 15:10:05 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

更新完成

all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:50:29   AP305   8444.0  TODO
1   2023-01-09 14:50:27   c2305   2884.0  TODO
2   2023-01-09 14:50:29   i2305    821.5  TODO
3   2023-01-09 14:50:29   j2305   2721.0  TODO
4   2023-01-09 14:50:27  jd2305   4354.0  TODO
5   2023-01-09 14:50:29   l2305   8005.0  TODO
6   2023-01-09 14:50:29  lh2303  15780.0  TODO
7   2023-01-09 14:50:29   m2305   3813.0  TODO
8   2023-01-09 14:50:29  rb2305   4089.0  TODO
9   2023-01-09 14:50:29  sp2305   6426.0  TODO
10  2023-01-09 14:50:29   y2305   8628.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:15:23 and 当前时间 <=2023.01.09 15:10:43 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:50:54   AP305   8445.0  TODO
1   2023-01-09 14:50:54   c2305   2883.0  TODO
2   2023-01-09 14:50:54   i2305    822.0  TODO
3   2023-01-09 14:50:54   j2305   2724.5  TODO
4   2023-01-09 14:50:50  jd2305   4354.0  TODO
5   2023-01-09 14:50:54   l2305   8008.0  TODO
6   2023-01-09 14:50:54  lh2303  15785.0  TODO
7   2023-01-09 14:50:54   m2305   3814.0  TODO
8   2023-01-09 14:50:54  rb2305   4092.0  TODO
9   2023-01-09 14:50:54  sp2305   6428.0  TODO
10  2023-01-09 14:50:54   y2305   8626.0  TODOsh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:16:23 and 当前时间 <=2023.01.09 15:11:43 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:51:19   AP305   8453.0  TODO
1   2023-01-09 14:51:18   c2305   2883.0  TODO
2   2023-01-09 14:51:20   i2305    822.0  TODO
3   2023-01-09 14:51:19   j2305   2723.5  TODO
4   2023-01-09 14:51:14  jd2305   4353.0  TODO
5   2023-01-09 14:51:20   l2305   8008.0  TODO
6   2023-01-09 14:51:20  lh2303  15795.0  TODO
7   2023-01-09 14:51:20   m2305   3815.0  TODO
8   2023-01-09 14:51:19  rb2305   4093.0  TODO
9   2023-01-09 14:51:19  sp2305   6420.0  TODO
10  2023-01-09 14:51:19   y2305   8630.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:17:01 and 当前时间 <=2023.01.09 15:12:21 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:52:49   AP305   8450.0  TODO
1   2023-01-09 14:52:48   c2305   2883.0  TODO
2   2023-01-09 14:52:49   i2305    822.0  TODO
3   2023-01-09 14:52:48   j2305   2724.5  TODO
4   2023-01-09 14:52:49  jd2305   4354.0  TODO
5   2023-01-09 14:52:49   l2305   8005.0  TODO
6   2023-01-09 14:52:48  lh2303  15770.0  TODO
7   2023-01-09 14:52:49   m2305   3816.0  TODO
8   2023-01-09 14:52:49  rb2305   4093.0  TODO
9   2023-01-09 14:52:49  sp2305   6424.0  TODO
10  2023-01-09 14:52:49   y2305   8634.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:17:39 and 当前时间 <=2023.01.09 15:12:59 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:53:14   AP305   8456.0  TODO
1   2023-01-09 14:53:14   c2305   2883.0  TODO
2   2023-01-09 14:53:14   i2305    821.0  TODO
3   2023-01-09 14:53:13   j2305   2723.0  TODO
4   2023-01-09 14:53:14  jd2305   4353.0  TODO
5   2023-01-09 14:53:14   l2305   8004.0  TODO
6   2023-01-09 14:53:14  lh2303  15790.0  TODO
7   2023-01-09 14:53:14   m2305   3818.0  TODO
8   2023-01-09 14:53:14  rb2305   4092.0  TODO
9   2023-01-09 14:53:14  sp2305   6426.0  TODO
10  2023-01-09 14:53:14   y2305   8630.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:18:17 and 当前时间 <=2023.01.09 15:13:37 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 14:54:16 CST)" was missed by 0:00:01.457827


select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:54:05   AP305   8449.0  TODO
1   2023-01-09 14:53:41   RM301   3490.0  TODO
2   2023-01-09 14:54:04   c2305   2883.0  TODO
3   2023-01-09 14:54:05   i2305    821.0  TODO
4   2023-01-09 14:54:05   j2305   2721.0  TODO
5   2023-01-09 14:54:05  jd2305   4353.0  TODO
6   2023-01-09 14:54:05   l2305   8005.0  TODO
7   2023-01-09 14:54:05  lh2303  15780.0  TODO
8   2023-01-09 14:54:05   m2305   3816.0  TODO
9   2023-01-09 14:54:05  rb2305   4090.0  TODO
10  2023-01-09 14:54:05  sp2305   6426.0  TODO
11  2023-01-09 14:54:05   y2305   8628.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:18:55 and 当前时间 <=2023.01.09 15:14:15 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:54:28   AP305   8448.0  TODO
1   2023-01-09 14:53:41   RM301   3490.0  TODO
2   2023-01-09 14:54:30   c2305   2884.0  TODO
3   2023-01-09 14:54:30   i2305    820.5  TODO
4   2023-01-09 14:54:30   j2305   2719.0  TODO
5   2023-01-09 14:54:30  jd2305   4352.0  TODO
6   2023-01-09 14:54:30   l2305   8002.0  TODO
7   2023-01-09 14:54:30  lh2303  15760.0  TODO
8   2023-01-09 14:54:30   m2305   3816.0  TODO
9   2023-01-09 14:54:30  rb2305   4085.0  TODO
10  2023-01-09 14:54:30  sp2305   6428.0  TODO
11  2023-01-09 14:54:30   y2305   8628.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:19:33 and 当前时间 <=2023.01.09 15:14:53 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:55:21   AP305   8446.0  TODO
1   2023-01-09 14:53:41   RM301   3490.0  TODO
2   2023-01-09 14:55:21   c2305   2885.0  TODO
3   2023-01-09 14:55:21   i2305    821.0  TODO
4   2023-01-09 14:55:21   j2305   2723.5  TODO
5   2023-01-09 14:55:20  jd2305   4354.0  TODO
6   2023-01-09 14:55:21   l2305   8008.0  TODO
7   2023-01-09 14:55:21  lh2303  15790.0  TODO
8   2023-01-09 14:55:21   m2305   3816.0  TODO
9   2023-01-09 14:55:21  rb2305   4086.0  TODO
10  2023-01-09 14:55:21  sp2305   6430.0  TODO
11  2023-01-09 14:55:21   y2305   8630.0  TODORun time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 14:56:16 CST)" was missed by 0:00:01.639020
Execution of job "main (trigger: interval[0:00:38], next run at: 2023-01-09 14:56:09 CST)" skipped: maximum number of running instances reached (1)

'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:20:11 and 当前时间 <=2023.01.09 15:15:31 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );

pocess_ins_vol.exit()
cannot unpack non-iterable NoneType object
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:21:27 and 当前时间 <=2023.01.09 15:16:47 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    sh: 1: dmidecode: not found
sh: 1: dmidecode: not found
/home/jerry/期货项目_最全/futures_base/log
initmoney [{}, {}]
v6.6.1_P1_20210406  9:27:14
trade connect...
开始交易
qry instrument
start qry thread
更新完成
logged
Trade logon: {"ErrorID":0, "ErrorMsg":"正确"}
account info
19693246.869999997, 0.0, 0.0, 0.0, 0.0, 0.0, 19693246.869999997, 19693246.869999997, 0.0
3664
['l2305', 'jd2305', 'c2305', 'm2305', 'lh2303', 'j2305', 'RM301', 'sp2305', 'y2305', 'rb2305', 'i2305', 'AP305']
quote connecting...
press ENTER key to release
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:22:38 and 当前时间 <=2023.01.09 15:17:58 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:56:54   AP305   8437.0  TODO
1   2023-01-09 14:56:53   c2305   2885.0  TODO
2   2023-01-09 14:56:54   i2305    821.0  TODO
3   2023-01-09 14:56:54   j2305   2721.5  TODO
4   2023-01-09 14:56:54  jd2305   4355.0  TODO
5   2023-01-09 14:56:54   l2305   8010.0  TODO
6   2023-01-09 14:56:54  lh2303  15795.0  TODO
7   2023-01-09 14:56:54   m2305   3816.0  TODO
8   2023-01-09 14:56:54  rb2305   4088.0  TODO
9   2023-01-09 14:56:54  sp2305   6430.0  TODO
10  2023-01-09 14:56:54   y2305   8632.0  TODO
ok
ok
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:23:16 and 当前时间 <=2023.01.09 15:18:36 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:58:40   AP305   8410.0  TODO
1   2023-01-09 14:58:39   c2305   2885.0  TODO
2   2023-01-09 14:58:40   i2305    822.5  TODO
3   2023-01-09 14:58:39   j2305   2724.5  TODO
4   2023-01-09 14:58:40  jd2305   4358.0  TODO
5   2023-01-09 14:58:40   l2305   8010.0  TODO
6   2023-01-09 14:58:40  lh2303  15795.0  TODO
7   2023-01-09 14:58:40   m2305   3819.0  TODO
8   2023-01-09 14:58:40  rb2305   4088.0  TODO
9   2023-01-09 14:58:40  sp2305   6430.0  TODO
10  2023-01-09 14:58:40   y2305   8632.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:23:54 and 当前时间 <=2023.01.09 15:19:14 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);
Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 14:59:55 CST)" was missed by 0:00:09.518488


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    

select top 1 当前时间,合约名称,最新价,操作  from allout
 context by 合约名称,date(当前时间 ) csort 当前时间  desc  having (( 当前时间.hour()>=9 and 当前时间.minute()>=43 and 当前时间.hour()<=15) or ( 当前时间.hour()>=21 and 当前时间.minute()>=15 and 当前时间.hour()<=23)) and 当前时间>=(now()-1000*60*2.95);


    select top 1 当前时间,合约名称,最新价 from allout context by 合约名称 csort 当前时间 desc
    
                   当前时间    合约名称      最新价    操作
0   2023-01-09 14:59:32   AP305   8427.0  TODO
1   2023-01-09 14:59:31   c2305   2885.0  TODO
2   2023-01-09 14:59:32   i2305    823.0  TODO
3   2023-01-09 14:59:32   j2305   2723.5  TODO
4   2023-01-09 14:59:32  jd2305   4359.0  TODO
5   2023-01-09 14:59:32   l2305   8010.0  TODO
6   2023-01-09 14:59:32  lh2303  15780.0  TODO
7   2023-01-09 14:59:32   m2305   3818.0  TODO
8   2023-01-09 14:59:32  rb2305   4092.0  TODO
9   2023-01-09 14:59:32  sp2305   6426.0  TODO
10  2023-01-09 14:59:32   y2305   8634.0  TODO
'NoneType' object is not iterable
更新完成
更新完成
更新完成

        login(`admin,`123456)
db=database('dfs://jerry');
futures=loadTable(db,`futures)
use ta;
use mytt;

defg dynimic(x,y){
	ymin=string(y[y.argmin()])
	ymax=string(y[y.argmax()])
	xmin=string(x[y.argmin()])
	xmax=string(x[y.argmax()])
	return xmax+'_'+ymax+'_'+xmin+'_'+ymin
	};


if((exec count(*) from getFunctionViews() where name="pocess_ins_vol")==1){  dropFunctionView("pocess_ins_vol")  };
go;
   def pocess_ins_vol(futures,mutable insrtuments){ 
    ix=0
endindex=insrtuments.regexFind("[0-9]")
if (endindex==-1){
//insrtuments=`jd
	品种名=insrtuments.lower()
	insrtuments=''
	}else{
品种名=insrtuments[0:endindex].lower()
	}
insrtument= distinct(trim(split(insrtuments,',')));   if(insrtuments.count()>0 and insrtuments.last()=="") insrtuments.pop!();
all=select  top 1000000  *  
,(accumulate(max,   REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) ) as `当前亏损值,accumulate(max, (accumulate(max, REF(最新价,90) )- REF(最新价,90))/accumulate(max, REF(最新价,90) )) as `当前最大亏损,
(( REF(最新价,90)-accumulate(min,   REF(最新价,90) ) )/accumulate(min, REF(最新价,90) ) ) as `当前盈利值,accumulate(max,( REF(最新价,90)- accumulate(min, REF(最新价,90) ))/accumulate(min, REF(最新价,90) )) as `当前最大盈利
,MACD( 最新价,5,14,9)[0] as `short_dif , MACD( 最新价,5,14,9)[1] as `short_dea , MACD( 最新价,24,47,9)[2] as `short_macd
  , MACD( 最新价,12,24,9)[0] as `mid_dif ,   MACD( 最新价,12,24,9)[1] as `mid_dea  , MACD( 最新价,24,47,9)[2] as `mid_macd
,move(成交量,1),move(持仓量,1),0 as `后4  ,int(当前时间),最新价
,iif( (最新价>= 开盘价 ),最高价-最新价,最高价-开盘价   ) as `上影线长度 , iif( (最新价>= 开盘价 ),开盘价-最低价,最新价-最低价   ) as `下影线长度
, iif( (最新价>= 开盘价 ), 最新价 - 开盘价 ,  开盘价 -最新价   ) as `实体线长度 
, CCI(最高价,最低价,最新价,5) as `CCI
,iif( (最新价>开盘价 ),`阳线,`阴线) as `flag线
 from futures where 当前时间>=2023.01.08 18:24:32 and 当前时间 <=2023.01.09 15:19:52 and 种名简称 = 品种名 and  (  insrtument.count()==0 || 合约名称 in insrtument ) context by date(当前时间),种名简称,合约名称   csort 当前时间 asc
	
all=select top 1000000 *,abs( mbeta( 最新价 ,int( timestamp(当前时间 )), 5)) as `movbeta  , moving(dynimic,[int_当前时间,CCI],4 ) as `calu
,move( moving(dynimic,[int_当前时间,CCI],4 ) ,1) as `diffcalu
from all context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间 asc;
 //update all set 成交量=( 成交量 - move_成交量 ) , 持仓量=(  持仓量-move_持仓量) 
 all=select top 1000000 *,BARSLAST(CROSS( mid_dif,mid_dea  ) ==1) as `MACD金叉,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间;
  all=select top 1000000 *, iif(MACD金叉<MACD死叉 and MACD金叉!=REF(MACD金叉,1) ,`MACD金叉,iif(MACD金叉>MACD死叉 and MACD死叉!=REF(MACD死叉,1) ,`MACD死叉 ,`TODO) ) as `MACD信号,BARSLAST(CROSS( mid_dea,mid_dif  ) ==1) as `MACD死叉 from all
 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间
nullFill!(all,0)
return  all
};
  addFunctionView(pocess_ins_vol);


all2=pocess_ins_vol(futures,ins[0])    
def mergetables( futures,mutable f ,lis ){
	for ( i in lis){	
	try{
i=pocess_ins_vol(futures,i) 
		f.append!(i) }catch(ex){}
		}
	}
mer=mergetables{ futures,all2}
ploop(mer, ins[1:]  );


all2=select top 100000 *,iif(short_dea>=0 and short_dif>=0 and CROSS(short_dea,short_dif )==1,`sell,iif( mid_dea<=0 and mid_dif<=0  and CROSS( mid_dif,mid_dea  ) ==1 ,`buy,`TODO))  as `MACD信号2  from all2 context by 种名简称,合约名称 ,date(当前时间 ) csort 当前时间;
nullFill!(all2,0);
    all2=select top 100000 * ,
iif(  当前亏损值>= 当前最大亏损>0 and   MACD信号==`MACD金叉  and MACD信号2==`buy and mid_macd>=0 and  movbeta<=move(movbeta,1) ,`buy,iif(  当前盈利值>= 当前最大盈利>0 and   MACD信号==`MACD死叉 and MACD信号2==`sell  and mid_macd<=0  and movbeta<=move(movbeta,1) ,`sell  ,`TODO) ) as `原始操作
from all2  context by  种名简称,合约名称 ,date(当前时间 ) csort 当前时间;

fulllis=[]
flaglis=[]
def  CCI趋势线(  tb, mutable fulllis, mutable flaglis ){
    for (i in tb ){
    try{
    n=i.calu.split('_')
    l=i.diffcalu.split('_')
    if(n[3]>l[3] and n[3]>l[3]){// print "下穿则卖出 "
    分子=( i.CCI- float(n[3] )  )/( i.int_当前时间-int(n[2]) )
    分母=( i.CCI- float( l[3] )  )/( i.int_当前时间-int( l[2] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!(`下穿则卖出 );
    }
    else if(n[1]<l[1] and n[0]>l[0]){
    分子=( i.CCI- float(n[1] )  )/( i.int_当前时间- int( n[0]))
    分母=( i.CCI- float( l[1] )  )/( i.int_当前时间-int( l[0] ))
    aw=分子-分母;
    fulllis.append!(aw);
    flaglis.append!( `上穿则买入);
 	} else{  fulllis.append!(0);flaglis.append!(`TODO )  }   } catch(ex){  fulllis.append!(0);flaglis.append!(`TODO )   }
    };
    }
    CCI趋势线(all2,fulllis,flaglis )
    update all2 set 方程值= fulllis$FLOAT
    update all2 set 方向=flaglis$STRING
     all2=select * from lj(all2,shareall3,`合约名称,`合约名称) ;
all2=select top 10000000 *,iif(最新价>min(lower,shareall3_最低价) or 最新价<max(upper,shareall3_最高价) ,`cando,`TODO  ) as `日度boll ,  BARSLAST( 方程值>0 and REF(方程值,1)<0) as `CCI趋势线金叉  , BARSLAST(  方程值<0 and REF(方程值,1)>0 ) as `CCI趋势线死叉 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
all2=select top 10000000 *,  iif(CCI趋势线金叉<CCI趋势线死叉 and CCI趋势线金叉!=REF(CCI趋势线金叉,1) and 方向==`上穿则买入 ,`CCI趋势线金叉,iif(CCI趋势线金叉>CCI趋势线死叉 and CCI趋势线死叉!=REF(CCI趋势线死叉,1) and 方向==`下穿则卖出 ,`CCI趋势线死叉 ,`TODO) ) as `CCI趋势线信号  from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 asc
  nullFill!(all2,0);
   allout=select  top 1000000 当前时间,合约名称,最新价 , iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线死叉 and 原始操作==`sell , `sell,iif( 日度boll==`cando and CCI趋势线信号==`CCI趋势线金叉 and 原始操作==`buy  ,`buy,`TODO )) as `操作 from all2 context by 种名简称,合约名称,date(当前时间 ) csort 当前时间 当前时间 desc
    Execution of job "main (trigger: interval[0:00:38], next run at: 2023-01-09 15:00:30 CST)" skipped: maximum number of running instances reached (1)
Run time of job "finding_2_cansole_trade (trigger: interval[0:00:12], next run at: 2023-01-09 15:00:43 CST)" was missed by 0:00:01.395417
